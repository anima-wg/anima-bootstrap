   WEEKLY INVITE, SEE ANIMA BOOTSTRAP WIKI: [1]https://trac.tools.ietf.org/wg/anima/trac/wiki/Bootstrap  draft is always at: [2]https://tools.ietf.org/html/draft-ietf-anima-bootstrapping-keyinfra-04
   NOTE NOTE NOTE: BRSKIEtherpad
   Current and most recent meeting notes are added to the BOTTOM of this document.
   The reason for this is so that we can consistently refer to line number and have them stay (mostly) the same as we add newlines. If Etherpad offered a feature for numbering from the bottom we could dispense with the pain of scrolling to the bottom of the document but:

       PLEASE SCROLL TO THE BOTTOM OF THIS DOCUMENT TO START/ENGAGE IN THE CURRENT MEETING
       PLEASE SCROLL TO THE BOTTOM OF THIS DOCUMENT TO START/ENGAGE IN THE CURRENT MEETING
       PLEASE SCROLL TO THE BOTTOM OF THIS DOCUMENT TO START/ENGAGE IN THE CURRENT MEETING
   2016-11-22:

   1) recap of IETF97.
   Summary: need to show progress w/ an implementation. A bake-off for Chicago?
   2) some discussion about minor restructing of document
   Address the "option overload" problem by moving anything that isn't strictly part of the anima use case into an appendix.
   The primary goal would be to hit the use case:
     *     Pledge<->Proxy<->Registrar

   (this is both the anima use case as well as a primary constrained device / IoT use case so we focus on it).
   The use cases of Pledge<->Cloud Proxy etc go into the appendix.
   Clarify that these are included and discussed to ensure that the security considerations are complete as additional bootstrapping methods can lead to unintended "downgrade" attacks. New bootrapping methods can be used to undermine existing methods so they all must be considered within the
   original threat modeling.
   AI: Michael to rip the doc apart for this
   Goal: A target for bake-off with minimal option choices
   3) the pair of EST over CoAP documents
     * -> expect to merge documents, no major issues.
     * -> is it BRSKI over CoAP, or EST over CoAP, ... "BRSKI over CoAP" inherently supports bootstrapping, which ACE cares more.
     * Where would/should this work be done?

   If we look at
   [3]https://tools.ietf.org/html/draft-vanderstok-core-coap-est-00#section-3.1
   "   The EST-coaps client MUST be configured with an implicit TA database
      or an explicit TA database.  The authentication of the EST-coaps
      server by the EST-coaps client is based on Certificate authentication
      in the DTLS handshake."
   This bootstrapping method does not work for a headless device. It assumes either:
   1) local configuration of the URI (implicit TA database)
   2) local configuration of the explicit TA database (explicit TA database)
   BRSKI is the 3rd approach:
       3) automatic bootstrapping of the TA database
   ACE will need to use (3) therefore will need to do "BRSKI over COAP".
   Need to communicate this back to ACE working group.
   AI: Michael engage on the ACE threads.
   4) use of M_FLOOD
   There is a lack of consensus as to GRASP vs mDNS for discovery of proxy, so we suggest that the full ANIMA Proxy MUST do M_FLOOD, (and in appendix X?) MUST do mDNS (and MAY do M_FLOOD in appendix).
   Or: Proxy MUST do mDNS and MUST do M_FLOOD.
   A new pledge SHOULD listen to mDNS or M_FLOOD, and MAY listen for both.
   5) getting ownership voucher document into shape (last, because I
      think we should get low-hanging fruit out of the way, and this will
      overflow into next week anyway)
   NEST/Thread discussion looks similar to this area.
   "Bearer Voucher" - the ability to use a bearer token to authenticate a voucher.
   [This moved to be bottom down on 2016-12-05]
   2016-11-29:
       present: mcr, max, kent.

       1) ownership-voucher.
       MCR talks about having read about CWT (CBOR version of JWT), and also the cose-message format which is used to sign CWT.
       CWT would express the voucher YANG definition directly.


       YANG has been used for a transactional protocol, but not been listed for something at REST.
       Kent says it is exactly what would happen if you fetched it with GET...

       parking the question: "how do we deal with the encoding"

       2) which working group should take this on.
       It will be ANIMA, and we will create new github group.

       3) bearer token discussion.
       We don't want to standardize a mechanism where a New Node/Pledge would directly accept such a voucher.

       [4]https://github.com/anima-wg


   2016-12-06:
       present: mcr, max, kent,toerless

       Discussion about one-touch, vs zero-touch devices.

   REcap last week:
     bearer token discussion: define a bearer token and explicitely declare it out of scope.
     * holographic: it is a voucher that is signed but the trusted-ca-cert/cacert/ownerid/trustanchr is not filled in. this allows anybody with a valid holographic bearer voucher to claim ownership.
     * psk voucher: it is a voucher that binds to a psk that the device already knows the psk. Also to be declared out of scope.
     * AI: max to write a voucher section for next call

     * security and operational deployment ramifications for each token type
     * future proofing


     Shepherd: Role to walk document from working group last call to IESG, traditional chairs, but encouraged to include other people (Mcr)

     What shepherding do we need ? Max: coding. security we should be fine.

     mcr: Mike Jones (michael.jones@microsoft.com) might be person or suggest a person.


     Max: any prototyping plans, interop testing ? what could we do for chicago ?

     Mcr: would need to do it at working group level. Saturday hackathon ?!

     Mcr sais he will have code by Chicago, Brian will have code.

     Kent: what interop wanted ? more than one version of component ? Mcr: yes, would be good.


   2016-12-13:
       present: max, mcr (has to hit washroom, back at 10:05), kent
       THANKS!
     *     [5]https://ietf.webex.com/ietf/j.php?MTID=m00a039327e09fc09340872992b151581
     *     Meeting number (access code): 644 519 877
     *
     * we had a section on vouchers: burried under imprint.
     * now is in the architecture part earlier in the document.
     * ... what is imprinting... introduces authorization layer.
     *
     * connected to OAuth --- this is a great idea.
     *

      Audit Voucher  Audit Vouchers are obtained by a Registrar from the
         MASA service and presented to the Pledge for validation.  These
         indicate to the Pledge that joining the domain has been logged by
         a logging service.  This mitigates a MiTM Registrar by allowing
         Registrars to examine log material.
             {mcr still has difficulties explaining this to others}
     *         if nonced it is "Trust on First Logged Use" (TOFLU)
     *         if nonceless, then it is a holographic voucher. and it is not TOFLU

     * If the "CA cert" is missing it is a bearer voucher.
     * If the device id was missing its a wildcard "master key" works for any device and we don't issue these
     * If the vendor checks ownership then this is roughly equivalent to an ownership voucher

   1. device attempts to join
   2. registrar obtains audit voucher
   3. registrar examines audit log
   4. registrar presents audit voucher to pledge
   5. pledge validate voucher *and* extracts public key of Registrar from the voucher as trust anchor
     pledge(MANU CA) --> verify(audit voucher)  -> 1) public key of owner
      Ownership Voucher  Ownership Vouchers are obtained by a Registrar
         from the MASA service and explicitly indicate the owner of the
         Pledge.  The Ownership Voucher is defined in
         [I-D.ietf-netconf-zerotouch].  This mitigates a MiTM Registrar by
         identifying the specific Registrar authorized to own the Pledge.
            This points to an ownership certificate by DN
            The ownership certificate is a PKI cert issued from the vendor to the Registrar
            Add reference/discussion to netconf zerotouch draft

   1. registrar enrolls with vendor to obtain "owner certificate"
      extended in recent netconf: owner certificate can be anchored from any CA, but then
      the trust anchor needs to be included in the voucher (if it is coming from vendor/MASA,
      then pledge would have trust anchor pre-hardcoded during manufacturing).
   2. device attempts to join
   3. registrar obtains ownership voucher which indicates DN of owner
   4. registrar presents ownership voucher to pledge
   5. pledge validates voucher *and* obtains and validates "owner certificate"
      pledge(MANU CA) --> verify(ownership voucher)  --> 1) name (DN) of owner.
                                                         3) hash of public key of owner?
                      --> 2) verify owner certificate (to check it is correct DN)  -> public key of owner

     - benefit over public-key: voucher with certificate can lie around unused as long as the
       trust anchor (CA cert) is valid - which can be a lot longer than the "normal" lifetime
       of a public key pair (which comes eg: a certificate of an owner). Eg: 20 years vs. 1 year.
   [6]https://tools.ietf.org/html/draft-kwatsen-anima-voucher-00
      Bearer Voucher  This voucher type is not defined within this
         specification.  Bearer Vouchers are a signed statement from the
         Vendor that any Registrar that possesses the voucher owns the
         Pledge.  Because the Registrar is not identified this voucher type
         must be treated as a secret and protected from exposure.
         Theoretically "nonced" and "nonceless" bearer vouches can exist.
         A nonceless bearer voucher effectively turns the Pledge into a
         "TOFU" device with minimal mitigation against MiTM Registrar's
         that have access to the bearer voucher.
      Pre-shared Key Voucher  This voucher type is not defined within this
         specification.  Pre-Shared Key Vouchers are cryptographically
         authenticated using a pre-shared symmetric key known to the Pledge
         and the Vendor.  This allows support for devices that can not do
         asymmetric key cryptographic operations.  Although this might
         provide an efficient method for ownership or bearer voucher
         authentication it does not provide the necessary Pledge
         authentication unless the pre-shared key is distributed to the
         Registrar.

   AI: try to build a table for this.
   2016-12-20:
       present: mcr, max, kent.


   Discussed this today:

       2.2.  Secure Imprinting using Vouchers
     A voucher is a cryptographically protected statement to the Pledge
     device indicating authorizing a zero-touch imprint on the Registrar
     domain.  Generically the voucher imparts the following information to
     the Pledge:
     Assertion Basis  Indicates the method that protects the imprint.
        This might include discrete ownership verification, assured
        logging operation or reliance on Pledge endpoint behavior such as
        secure root of trust of measurement.  Only some methods are
        normatively defined in this document.  Other methods are left for
        future work.
     Registrar Authentication  Indicates how the Pledge can authenticate
        the Registrar.  This might include an indication of the PKIX trust
        anchor used by the Registrar, or an indication of shared PKIX
        trust anchor and additional CN-ID or DNS-ID information to
        complete authentication.  Symetric key or other methods are left
        for future work.
     Anti-Replay Protections  Time or nonce based information constrain
        vouchers to time periods or bootstrap attempts.
     A number of boostrapping scenarios can be met using differing
     combinations of this information.  All scenarios address the primary
     threat of a MiTM Registrar gaining control over the Pledge device.
     The primary voucher combinations are referred to within this document
     by name:
                  |Assertion   |Registrar ID    |Pledge ID | Validity    |
                  |Log-|Veri-  |Trust  |CN-ID or|serial    | RTC | Nonce |
                  | ged|  fied |Anchor |DNS-ID  |number    |     |       |

   AI: rename: Registrar ID to "domain ID" and add "role information" remove/minimize pledge id (everybody gets one)

     --------------------------------------------------------------------|
     Audit        |  X |       | X     |        | X        |     | X     |
     -------------|----|-------|-------|--------|----------|-----|-------|
     Nonceless    |  X |       | X     |        | X        |     |       |
     Audit        |    |       |       |        |          |     |       |
     -------------|----|-------|-------|--------|----------|-----|-------|
     Owner Audit  |  X |   X   | X     |        | X        |     | X     |

     Owner Role   |  X |   ?   | X     |  X     | X        |     | X     |
     -------------|----|-------|-------|--------|----------|-----|-------|
     Owner ID     |    |   X   | ?     |  X     | X        | X   |       |
     -------------|----|-------|----------------|----------|-------------|
     BearerVoucher|  X |       |   wildcard     | X        | ?           |
     -------------|----|-------|----------------|----------|-------------|
     MasterVoucher|    |       |   wildcard     | wildcard | X   |       |
     -------------|------------|----------------|----------|-----|-------|
   SUGGEST: read the google ct discussion at: [7]https://www.certificate-transparency.org/how-ct-works
   this might inform how max is thinking about audit logs and the overlap with x509 CN-ID (max's argument is that x509 when done right really means checking audit logs anyway so lets go straight to that model and avoid the x509 authentication questions. With admission that x509 as a model
   fully exists and therefore is a logical approach many folks are comfortable with. thus the "option" we have been building into our drafts).
   CN-ID or DNS-ID could be renamed "RFC6125"?
   Kent NOTEs: signing mechanisms needs to be able to pass a chain of certificates. this is a key characteristic.
   2017-1-3
     * present: max, mcr, kent
     *
     * Voucher document will list the different attributes of the voucher, and explain how to process each of the attributes. Some of the combinations will be named.
     * The BRSKI document will explain when to use each named vouch combination.
     *
     * from CWT:
     *
     *    3.1.  Claim Names . . . . . . . . . . . . . . . . . . . . . . .   4
     *        3.1.1.  iss (Issuer) Claim  . . . . . . . . . . . . . . . . .   4
     *        3.1.2.  sub (Subject) Claim . . . . . . . . . . . . . . . . .   4
     *        3.1.3.  aud (Audience) Claim  . . . . . . . . . . . . . . . .   4
     *        3.1.4.  exp (Expiration Time) Claim . . . . . . . . . . . . .   5
     *        3.1.5.  nbf (Not Before) Claim  . . . . . . . . . . . . . . .   5
     *        3.1.6.  iat (Issued At) Claim . . . . . . . . . . . . . . . .   5
     *        3.1.7.  cti (CWT ID) Claim  . . . . . . . . . . . . . . . . .   5
     *
     *
     * [8]https://datatracker.ietf.org/wg/cose/documents/
     *
     * AI: mcr to put together normative text on using CWT for Voucher use.
     *
     * "4" is a blog (gets a signature)  (voucher)
     * "5" is a blog (gets a signature)  (revocation list)
     * what are the fields and how to process them.
     * what are the signatures and how/when to create them:
     * ... new section 6, signing strategy, also about revocation strategy.
     *
     * first prong: review of table of contents... what's missing is an overview and introduction.... tree diagram is presented is as part of the overview.
     * section 4.1: before diagram... field called "assertion" --- if it is logged, this is what it means.  then field "trusted CA".
     *

   2017-1-10
     * present: max, mcr, kent, toerless

   AI: max to add terminology section to voucher doc
       pledge - we're good on this
       owner domain - for owner's domain. where registrar
       MASA - for "manufacturer or delegate". Then in the BRSKI doc *name* the REST interface to the MASA.
   AI: update voucher ToC as such:
   ToC to be:
   Intro
    terminology
    requirements
    tree diagram notation
    secure imprinting using voucher

   voucher
    tree diagram
    examples, etc

   AI: kent to add normative reference to yang->json RFC as the encoding type.

   2017-1-17
     * present: max, kent, mcr, toerless

   Anima terminology change for consistency with 6tisch:
      Anima "Proxy" to be "Join Proxy"
     * Registrar to be "Join Registrar and Coordinating" (JRC) with intro/terminology indicating use of abbrviated terms in the body. Q: what does 'coordinator' imply? That it "makes sure doesn't accept
     * too many join processes at the same time" and "drives them" to manage bandwidth.

      Join Registrar  or maybe Join Registrar (and Coordinator).

   DONE. AI: mcr will write email summarizing change of terminology.
   3.1.1.  Discovery
      The result of discovery is a logical communication with a Registrar,
      through a Proxy.  The Proxy is transparent to the Pledge but is
      always assumed to exist.
      To discover the Registrar the Pledge performs the following actions:
      a.  MUST: Obtains a local address using IPv6 methods as described in
          [RFC4862] IPv6 Stateless Address AutoConfiguration.  [RFC7217] is
          encouraged, but see Section 9.  IPv4 methods are described in
          Appendix A
      b.  MUST: Listen for GRASP M_FLOOD ([I-D.ietf-anima-grasp])
          announcements of the objective: "ACP+Proxy".  See section
          Section 5 for the details of the the objective.  The Pledge may
          listen concurrently for other sources of information, see
          Appendix B.
      Once a proxy is discovered the Pledge communicates with a Registrar
      through the proxy using the bootstrapping protocol defined in
      Section 7.
      Each discovery method attempted SHOULD exponentially back-off
      attempts (to a maximum of one hour) to avoid overloading the network
      infrastructure with discovery.  The back-off timer for each method
      MUST be independent of other methods.  Methods SHOULD be run in
   Discussion: Need more statements about liars claiming devices. Current discussion is in security considerations but needs more. In particular discussion about Proof-of-possession. A suggestion is that having devices avoid leaking their serial# widely can help prevent a "lazy" attack where
   the attacker doesn't know/guess the serial number in advance. The underlying problem and solution should be discussed independent of the discovery mechanism... but there is an overlap
     *
     *

   AI: The M_FLOOD vs mDNS initial discovery discussion is not over, and we should invite the DNSSD/mDNS folks to come and make the case.
   Guys, I need to go now - Kent
   AI: security considerations of parallel vs sequential connection.
   Toerless:
       (R)ight: L2 discovery protocol requirement:
           proxy needs to periodically (unsolicited) announce its proxy service via L2 multicast/broadcast
           pledge only accepts reply if it was multicast/broadcast
           pledge should then try to register via such discovered proxies.
               if multiple proxies discovered, parallel and/or sequential -> more difficult discussion
       (W)rong: The opposite is NOT a good solution:
           pledge sends out L2 multicast/broadcast queries for proxy
           proxy sends unicast reply to pledge
           pledge then tries to register via such discovered proxies.
       Reason:
           Whether we do (R)right or (W)rong, the pledge has no good way to protect itself against such an L2
           attacker. Attacker may be able to look like many proxies, resulting in DoS attack against pledge.
           If we do (R)ight, then a third-party (eg: valid proxy) on the same L2 domain can much easier
           discover the attacker - because attacker MUST broadcast/multicast itself.
       Example:
           Ethernet LAN. Valid proxy is router, attacker is host with malware acting as proxy. In (R)ight,
           Valid proxy would immediately see attacker due to its multicasts. In (W)rong, the only way to
           discover attacker by third-party is to have a discovery-unicast-reply message spoofing function
           in the L2 switch of the LAN - much more complex requirement.
       Notes:
           The security of (R)ight depends on pledge being able to see if received packet from proxy was L2
           unicast or multicasted. This information is typically ignored in existing network protocol stacks
           and is also typically unavailable on the socket-API. This IMHO makes it highly beneficial to
           use a very lightweight protocol (like the subset of GRASP dedicate to this) that can specifically
           be implemented to do this security check.

           Example/Proof: WiFi
           WiFi client joining to a multicast group to receive traffic. APs with proprietary
           multicast->unicast feature (eg: Cisco Videostream, but every business AP vendor has this now)
           send out to every joined client the L3 multicast stream as L2 unicast so that the WiFi L2
           retransmission of WiFi can be used (no L2 multicast retransmissions defined in 802.11 so far).
           This trick relies on on the fact that the L3 multicast stack and socket API on hosts completely
           ignores the MAC address layer of multicast packets.

           Note too that L2 technologies (Ethernet/WiFi) often make it easy to fake the L2 source address,
           therefore allowing attackers to masquerae as many proxies. BUT: these technologies make it
           hard or impossible to fake a multicast packet. In Ethernet this is impossible. Not sure how
           difficult/easy it is in WiFi for HW to fake a multicast packet wrt. to the multicast
           indication in the packet header.

           Wrt to mDNS (RFC6762):
           1. There is no text to discuss that L2 unicast messages must be ignored for L3 mDNS messages
              that are meant to be multicast.
           2. There is explicit text prohibiting periodic unsolicited announcements:
              A Multicast DNS responder MUST NOT send announcements in the absence
              of information that its network connectivity may have changed in some
              relevant way.  In particular, a Multicast DNS responder MUST NOT send
              regular periodic announcements as a matter of course.


   2017-01-24:
   present: max, kent, mcr
   AI: The M_FLOOD vs mDNS initial discovery discussion is not over, and we should invite the DNSSD/mDNS folks to come and make the case.
   AI: security considerations of parallel vs sequential connection.
   Kent: There was an issue in NETCONF how hot to use YANG to document artifacts (file formats, etc.).  This is a syntactic enhancement to the YANG definition.
   Agenda:
       1)
   AI: Movingn BRSKI stuff to voucher doc continued
     * Voucher doc -> gains the high level arch diagram and Pledge, "inventory tracking" Registrar, and MASA definitions
     * BRSKI doc -> references this and expands "Join Registrar" to be a specific BRSKI server
     * netconf -> references voucher and expands "[foo] Registrar" to be a [manual process or other]
     *
     *
     * Kent would like Registrar to be a conceptual entity that passes the Voucher from MASA to Pledge.
     *
     *
     * 2) proxy section.  Normative reference for IPIP
     * 3) How to do CoAP (over PEAP? TEAP? EAP-TLS? EAP-TTLS?, over 802.1X.). Remove 3.2.1 CoAP, and leave it for another document.
     * AI: mcr to revise, simplify and augment this section to make it obvious that it should be extended.
     *

   Feb.13: goal to have all three documents.
   Juniper vs Cisco PKCS7 voucher creation/interop in Chicago.
   Will use PKCS7 with RSA signatures initially.
     *

   2017-01-31:
     *     present: mcr, kent, max
     *
     * discussion about OSCP vs CRLs.
     * Question about PKCS7 vs CWT etc. for encoding of the voucher.
     * The registrar needs to be aware of the contents of the voucher for reasons of auditing, otherwise the format of the voucher *COULD* be private between the MASA and the pledge.
     *
     * Discussion about option by which JRC can decide to pass unknown formats for the voucher through to the pledge, should it wish to forgo auditing.
     *
     *

   1. PK7 escapsulated ( json-payload, signature, + [CRLs or Certs] )
              format signalled by outside content-type (JSON encoded YANG data, for instance), for instance.
              "The Audit Voucher response is encapsulated in a [RFC5652] Signed-data that is signed by the MASA server." "with a content-type of application/authorizationvoucher" -04 section 5.3
   2. CWT-encapsulated ( EdDSA-signed-CBOR object ) + (??-unknown revocation)
     *
     * register requests voucher from MASA, and contains a version field -04 section 5.1
     * the registrar caches the audit voucher response: application/authorization-voucher, or application/authorization-voucher-2, application/authorization-voucher-jwt -04 section 5.3
     * Registrar is NOT REQUIRED to parse this object, but it SHOULD do so if it needs to AUDIT.

   On a USB key, the filename extension substitutes for the HTTP 200 content-type; as is usual in the industry
   filename examples:
     - voucher.pk7  // suffix signals #1
     - voucher.cwt  // suffix signals #2

     AI: write IANA Considerations section registering application/authorization-voucher.

   Follow the format of RFC7030 section5 IANA template in final draft which becomes section5 of RFC7030
   [9]https://tools.ietf.org/html/rfc7030#section-5
   for example:
      The media subtype for CSR attributes in a CSR Attributes Response is
      application/csrattrs.
   we will end up with a similar statement about application/authorizationvoucher
   2017-02-07
       present: kent, max, mcr, toerless

       Is the WebEX server down?

       Other webex servers seem up and the main www.webex.com site is up. My hardware VPN is down though so I don't have access to any internal reports at the moment. We can webex here as an alternative:
       [10]https://cisco.webex.com/join/pritikin

        okay.


       Agenda:  1) content-types
       Using these section headers: [11]https://tools.ietf.org/html/draft-ietf-anima-bootstrapping-keyinfra-04

       s5
       These extensions MUST
      be supported by the Registrar EST server within the same .well-known
      URI tree as the existing EST URIs as described in [RFC7030] section
      3.2.2.

       s.5.1 request voucher from registrar POST
            /brski/rv

     *     application/requestvoucher  or application/json  or application/<object>+<encoding> [passing 'object' important only if can vary]

       s.5.2 request voucher from MASA

       s.5.3 audit voucher response

     * application/voucher+pk7   <----- we will consistently go with this style for each section

   AI: kent to where the +pk7 stuff is defined
       s.5.7.4 Enrollment Status Telemetry

     * /est/status    <- advantage of shorter. advantage clearly an est status message (would require this RRC *updates* 7030)
     * /brski/status  <- advantage that this is clearly a brski defined message

   Link to iana page for he media types above. try to re-use:
   [12]https://www.iana.org/assignments/media-types/media-types.xml   (searching for "pk" produces interesting results!)
   RFC6838: Media Type Specifications and Registration Procedures
        restricted-name-chars =/ "+" ; Characters after last plus always
                                     ; specify a structured syntax suffix

       [13]https://tools.ietf.org/html/draft-ietf-netconf-restconf-12#section-3.1
       Minimizing the re-direction would minimize the round trips.

       I prefere /.well-known/est/TLA or /.well-known/brski/TLA
       why TLA and not a more human readable? CoAP.  But I don't think it's that important.
       [14]https://tools.ietf.org/html/rfc5785
       action item: max to update text consistent with this.

       2) interop plans -- details.


       Interop/Hackathon  ([15]https://www.ietf.org/hackathon/98-hackathon.html)
       =================
       AI: to request space durint hackathon. probably 3-4 peoples.
       AI: write emails to list about plans.


   2017-02-14 (happy hallmark day!):
       present: mcr,max, kent
   from the 6tisch-security meeting, some diagrams:
      [16]http://www.sandelman.ca/SSW/ietf/6tisch/  see pledge-join-states_EB.svg (or .png)

          ** If one permits redirects, and there is a MITM, the MITM can force the pledge to follow the redirects. Including, "wait a bit and retry" (HTTP message... xxx) may be able to replay the redirect.**
    [17]https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After  <-- explains 503/301 Retry-After
   AI max: look to see if there is something better than 503 for human introduced delay. The "The server also MAY include informative human-readable content" statement from RFC7030 might provide this information but at the cost of a large number of bytes.
   Indicate a maximum amount of time before retry. Perhaps expressed as a f(delay before trying other registrars).
   Explain the human involvement on the Registrar piece
   2017-02-21:
     *     present: max, mcr, kent, toerless
     *
     * max: 503 delay not yet committed.
     * max: question about proxy discussion.
     * kent: did not get to update voucher draft.
     *
     * 1) proxy discussion
     * 2) voucher draft, identifying the ownership certificate via it's subject matter, CN/DNS/etc.  (sub key id, auth key id)
     * 3) interop testing discussion.
     * 4) defense against attacker looking like many Join Proxy
     *
     * Proxy discussion

   Current text IPIP forwarding mechanism.
   current writeup does not articulate it well enough, 3.2.1 CoAP. Dropped CoAP discussion.
   Let's drop CoAP discussion completely for now.
   We could drop CoAP, but talk about TCP and UDP instead.
   Implementers do not know what to implement: needs to say more.
   TCP circuit proxy or IPIP encapsulation of TCP packet.
   ACTION ITEM: mcr update the text to say that registrar / JP need to decide upon a mechanism.
   ACTION ITEM: mcr need to write up IPIP forwarding better.
   ACTION ITEM: mcr to update 3.2.2, and remove 3.2.1 for now.
   Because this is between the Proxy and Registrar there is no change in behavior by the Pledge.
   There can be options; they would be negotiated by the this:
   6.  Registrar Discovery Protocol Details
      The registrar responds to discovery messages from the proxy (or GRASP
      caches between them) as follows:
      objective         = ["AN_registrar", F_DISC, 255 ]
      discovery-message = [M_DISCOVERY, session-id, initiator, objective]
      Figure 6: Registrar Discovery
      The response from the registrar (or cache) will be a M_RESPONSE with
      the following parameters:
      response-message = [M_RESPONSE, session-id, initiator, ttl,
                         (+locator-option // divert-option), ?objective)]
      initiator = ACP address of Registrar
      locator1  = [O_IPv6_LOCATOR, fe80::1234, 6,  443]
      locator2  = [O_IPv6_LOCATOR, fe80::1234, 17, 5683]
      locator3  = [O_IPv6_LOCATOR, fe80::1234, 41, nil]
   Does this mean:
     *     response-message = [?, session-id, initiator, ttl, locator1 + locator2 + locator3, objective="AN_registrar"]

      Figure 7: Registrar Response
   "  The GRASP protocol treats the objective name as an opaque string.
      For example, "EX1", "411:EX1", "example.com:EX1", "example.org:EX1
      and "user@example.org:EX1" would be five different objectives."
   ACTION: expand text of section 6 to explain how these three responses map to specific Join Proxy behaviour.
   {6/xxx   = TCP circuit proxy to port xxx, HTTPS EST,
    17/yyyy = CoAP circuit proxy to port yyyy,
    41/0    = IPIP encapsulation
    }
   so, maybe the ?objective should involved here too!!!
   Decision for section 3:
     * Implement circuit proxy on proxy. No change to Pledge. Easy implemnetation on Registrar (no change from current test cases).
     * For scalability / future proofing we indicate here that future proxy models may/will/even-now exist. Section 7 will be updated to indicate how they are signaled because this forces grasp/ACP to improve.
     *

   AI: Michael to update section3 of the doc to reflect.
   2) voucher document.
     * Anchor is "Versign's CN=FOO" or "Verisign's dnsName=FOO", but would like to use entire subjectAltName.
     * subject = X509 DN (abstracted from key itself)
     * subjectKey = actual public key
     * subjectKeyIdentifier = hash of public key.

   section 4.2.1.2 of rfc5280.
   this lacks the level of indirection desired.
   this field rfc6125 validation
   Kent AIs:
     - add subject-hash details
     - add indirect issuer details
     - look into v3 extension option
   2017-02-28:
       lousy no good two bit no show: max pritikin
       present: everybody else

       Folks, i'm sorry for the late notice but i'm not going to be able to join this week. I haven't much to report on the document front.
       I hope to send some example/test protocol messages via email later in the week.
       I also dropped you all an email.

   2017-02-28: (11am)
       present: kent, mcr, toerless,

   1) interop planning. 20minutes max.
     * Kent: standalone test environment, openssl/Makefile/C-code to do some things that CLI won't use.

     * Goes through entire gamit and creating voucher and revocation and anchor/intermediates.
     * Not really interop... convert from PKCS7 to other format.
     * The voucher was written in JSON per draft.
     *

         MCR:  wanted to have, COSE signed CWT format voucher.
               Totally non-interoperable with above. Not aligned with current draft.
               mcr agrees to work towards PKCS7 signed items....

     *

   2) getting the -05 out the door (20 minutes max)
   3) I was asked to write about IPIP encapsulation.
      [18]https://github.com/anima-wg/anima-bootstrap/commit/bba6351458955862965c71199b2f8a94f90cf169
      There are some provisioning issues that came up.  I tried to capture some
   of the updates in:
        [19]https://github.com/anima-wg/anima-bootstrap/commit/e049ec790a7051d54094bfca9d8921e59d7458e5

   RFC7519 - JWT - is that a good format for voucher content ?
   CWT -> michael would like that for 6TSCH.
   JWT Libraries could already interpret JWT objects.
      - JWT library should be able to give us:
           - Encode/decode of voucher object
           - create/verify signature
           - validating the claim - checking whether claim applies to situation
               - eg: in voucher check that voucher is for the pledge
                 (eg: if we refer to pledge via DN, serial number, certificate-hash,...)
                 these options will likely still need to be defined/implemented on top of JWT library. probavbly not predefined
           - validating that claim is current (if JWT contains timestamps)
             JWT has some time we don't need, but may need to add our own notion of time (Michael).
           - .. other aspects..
   [20]https://stackoverflow.com/questions/39909419/jwt-vs-oauth-authentication
   2017-03-07:
       present: max, mcr, kent, toerless
   recap of last week... discussion about RFC7519 section 4 claims
   - Michael would like CWT (CBor) - but not far enough in stds. to be used. So using JWT for now.
   - Toerless would like to see JWT explored during hackathon to summarize practical experience with claimed benefits,
   eg: summarize on a page for ANIMA WG meeting.
   - Max thinks JWT investigation lower priority . eg: use JSON structures from doc right now in Hackathon, look only into JWT if there is time left during hackathon.
   - Kent opposed to use JWT for now - as long as its not clear how to do revocations. Unclear if short-lived certificates are sufficient - aka: not require revocations.
   Stick with PKCS7 signed YANG derived JSON.
   Struggling with use cases in order to justify needing to revoke vouchers.
   MCR proposes a way to use standard CRLs.
   [actually this was max]
   Max and Kent discussion about how to use OCSP / "standard CRLs" to address revocation
   The basic plan is to see what modifciations we'd make to the ietf-voucher yang file to support this.
   module ietf-voucher {
     yang-version 1.1;
     namespace
       "urn:ietf:params:xml:ns:yang:ietf-voucher";
     prefix "vch";
     import ietf-yang-types {
       prefix yang;
       reference "RFC 6991: Common YANG Data Types";
     }
     import ietf-inet-types {
       prefix inet;
       reference "RFC 6991: Common YANG Data Types";
     }
     import ietf-restconf {
       prefix rc;
       description
         "This import statement is only present to access the yang-data
          extension defined in RFC 8040.  The yang-data extension doesn't
          itself have anything to do with RESTCONF, but was placed in the
          that RFC for convenience.  This extension is being tracked to
          be moved to the next version of the YANG modeling language.
          Regardless where or how this extension statement is defined,
          there should not be any impact to a voucher's encoding.";
       reference "RFC 8040: RESTCONF Protocol";
     }
     organization
      "IETF ANIMA Working Group";
     contact
      "WG Web:   <[21]http://tools.ietf.org/wg/anima/>
       WG List:  <[22]mailto:anima@ietf.org>
       Author:   Kent Watsen
                 <[23]mailto:kwatsen@juniper.net>
       Author:   Max Pritikin
                 <[24]mailto:pritikin@cisco.com>
       Author:   Michael Richardson
                 <[25]mailto:mcr+ietf@sandelman.ca>";
     description
      "This module defines the format for a voucher, which is produced by
       a pledge's manufacturer or delegate (MASA) to securely assign one
       or more pledges to an 'owner', so that the pledges may establish a
       secure connection to the owner's network infrastructure.";
     revision "YYYY-MM-DD" {
       description
        "Initial version";
       reference
        "RFC XXXX: Voucher and Voucher Revocation Profiles
         for Bootstrapping Protocols";
     }
     rc:yang-data voucher-artifact {
       uses voucher-grouping;
     }
     grouping voucher-grouping {
       description
         "Grouping only exists for pyang tree output...";
       container voucher {
         config false;
         description
           "A voucher that can be used to assign one or more
            pledges to an owner.";

     // ASN1 from X509 is
     // RFC5280 4.1.2.2 "The serial number MUST be a positive integer assigned by the CA to each certificate."
     // CertificateSerialNumber  ::=  INTEGER
         leaf serial-number {
           type uint32'
           description
             "included when the masa anticipates revoking nonce-less vouchers.";
         }



      // from 5280: 4.2.1.1.  Authority Key Identifier
      /*
      "The identification MAY be based on either the
      key identifier (the subject key identifier in the issuer's
      certificate) or the issuer name and serial number."

      The voucher AKI MUST be the subject key identifier from the MASA certificate used to sign the voucher
      */
      AuthorityKeyIdentifier ::= SEQUENCE {
         keyIdentifier             [0] KeyIdentifier           OPTIONAL,
         authorityCertIssuer       [1] GeneralNames            OPTIONAL,
         authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }
      KeyIdentifier ::= OCTET STRING

      leaf authority-key-identifier {
        type binary;
        description
          "the Subject Key Identifier of the MASA's leaf certificate.
           The voucher AKI MUST be the subject key identifier from the MASA certificate used to sign the voucher";
      }
     // ASN 1 from x509 is
     // RFC5280 s4.2.2.1
     //
     // alternatively the pledge never access the revocation information at all.
     // instead the voucher bundling would be stapled into the CMS via:
     [26]https://tools.ietf.org/html/rfc5652#section-10.2.1
     // but this doesn't work for long lived vouchers. because the registrar can't update the cms
     // and the masa can't put relevant "long lived" revocation information (that would take a time machine)
     // the ASN1 would be:
        SignedData ::= SEQUENCE {
        version CMSVersion,
        digestAlgorithms DigestAlgorithmIdentifiers,
        encapContentInfo EncapsulatedContentInfo,
        certificates [0] IMPLICIT CertificateSet OPTIONAL,
        crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
        signerInfos SignerInfos }


         /*
       id-pe-authorityInfoAccess OBJECT IDENTIFIER ::= { id-pe 1 }
      AuthorityInfoAccessSyntax  ::=
              SEQUENCE SIZE (1..MAX) OF AccessDescription
      AccessDescription  ::=  SEQUENCE {
              accessMethod          OBJECT IDENTIFIER,
              accessLocation        GeneralName  }
      id-ad OBJECT IDENTIFIER ::= { id-pkix 48 }
      id-ad-caIssuers OBJECT IDENTIFIER ::= { id-ad 2 }
      id-ad-ocsp OBJECT IDENTIFIER ::= { id-ad 1 }
         */

         // From RFC5280 "When id-ad-ocsp appears as accessMethod, the accessLocation field is
      the location of the OCSP responder, using the conventions defined in
      [RFC2560]." which is actually: [27]https://tools.ietf.org/html/rfc6960#section-3.1
      So we are saying this is a list of URIs
         leaf-list authority-info-access {
           when "../assertion == "long";
           type inet:uri;
           description
             "This is handled the same way you handle the list inside a certificate.
              Pleadge is never responsbile for fetching OCSP Response.";
         }
         leaf assertion {
           type enumeration {
             enum long {
               description
                 "Indicates that the ownership has been positively
                  verified by the MASA (e.g., through sales channel
                  integration).";
             }
             enum short
             enum logged {
               description
                 "Indicates that this ownership assignment has been
                  logged into a database maintained by the MASA, after
                  first verifying that there has not been a previous
                  claim in the database for the same pledge (voucher
                  transparency).";
             }
           }
           mandatory true;
           description
             "The assertion is a statement from the MASA regarding how
              the owner was verified.   This statement enables pledges
              to support more detailed policy checks.  Pledges MUST
              ensure that the assertion provided is acceptable before
              processing the voucher.";
         }

         leaf trusted-ca-certificate {
           type binary;
           mandatory true;
           description
             "An X.509 v3 certificate structure as specified by RFC 5280,
              Section 4 encoded using the ASN.1 distinguished encoding
              rules (DER), as specified in ITU-T X.690.

              This certificate is used by a pledge to trust a public key
              infrastructure, in order to verify a domain certificate
              supplied to the pledge separately by the bootstrapping
              protocol.  The domain certificate MUST have this certificate
              somewhere in its chain of certificates.
              This field is optional because it may not be needed by all
              bootstrapping protocols.
              Note: the expiration date of this certificate effectively
                    imposes an upper limit on the voucher's expiration.";

           reference
             "RFC 5280:
                Internet X.509 Public Key Infrastructure Certificate
                and Certificate Revocation List (CRL) Profile.
              ITU-T X.690:
                 Information technology - ASN.1 encoding rules:
                 Specification of Basic Encoding Rules (BER),
                 Canonical Encoding Rules (CER) and Distinguished
                 Encoding Rules (DER).";
         }

         container domain-certificate-identifier {
           must "../trusted-ca-certificate" {
             description
               "A trusted-ca-certificate must be present whenever
                this node is present";
           }
           description
             "This container identifies specific values that a domain
              certificate, provided to the pledge separately by the
              bootstrapping protocol, MUST contain.  This is useful
              when, for instance, the trust anchor is a long-lived
              public CA certificate, while the domain certificate is
              reissued periodically.
              When provided, the pledge MUST perform RFC 6125 style
              validation of the domain certificate against all of
              the provided values.
              This container is optional because it is unneeded when,
              for instance, the trusted CA certificate is owned by the
              domain (i.e.  a private PKI), and hence the trust model
              can be more relaxed.";
           leaf subject {
             type binary;
             description
               "The certificate's entire subject field MUST match
                this value.  This value is the Subject structure, as
                specified by RFC ???? Section ???, encoded using the
                ASN.1 distinguished encoding rules (DER), as specified
                in ITU-T X.690.";
           }
           leaf cn-id {
             type string;
             description
               "The certificate's subject field's 'common name' value
                MUST match this value.";
           }
           leaf dns-id {
             type string;
             description
               "A subjectAltName entry of type dNSName in the
                certificate MUST match this value.";
           }
         }

         leaf device-identifier {
           type string;
           mandatory true;
           description
             "A unique identifier (e.g., serial number) within the scope
              of the MASA.

              When processing a vouchers, pledges MUST ensure that their
              unique identifier matches at least one regular expression in
              the list.  If no matching regular expression is found, the
              pledge MUST NOT process this voucher.";
         }

         leaf nonce {
           type binary {
             length "8..32";
           }
           description
             "A value that can be used by a pledge in some bootstrapping
              protocols to enable anti-replay protection.  This node is
              optional because it is not used by all bootstrapping
              protocols.

              When present, the pledge MUST compare the provided nonce
              value with another value that the pledge randomly generated
              and sent to a bootstrap server in an earlier bootstrapping
              message.  If the values do not match, then the pledge MUST
              NOT process this voucher.";
         }

         leaf created-on {
           type yang:date-and-time;
           mandatory true;
           description
             "A value indicating the date this voucher was created.  This
              node is optional because its primary purpose is for human
              consumption.  However, when present, pledges that have
              reliable clocks SHOULD ensure that this created-on value
              is not greater than the current time.";
         }

         leaf expires-on {
           type yang:date-and-time;
           description
             "A value indicating when this voucher expires.  The node is
              optional as not all pledges support expirations, such as
              pledges lacking a reliable clock.

              If the pledge supports expirations and the expires-on value
              is less then the current time, then the pledge MUST not
              process this voucher.";
         }

         leaf-list revocation-location {
           type inet:uri;
           description
             "Zero or more URIs indicating where revocation information for
              this voucher may be obtained.  This node is optional as not
              all pledges may support processing revocations.  More than
              one URI may be provided for high-availability reasons.  The
              URL may address an issuer-wide revocation document or a
              voucher-specific revocation document.

              A pledge may also obtain voucher revocation information from
              the same source where it obtained the voucher.  In this case,
              the pledge SHOULD attempt to obtain a potentially newer
              voucher revocation but, if it is unable to, for whatever
              reason, the pledge MUST process the provided voucher
              revocation.

              If a pledge processes a voucher revocation that indicates a
              voucher is no longer valid, then the pledge MUST not
              process the voucher.  If a pledge is unable to process any
              voucher revocation, then the pledge SHOULD NOT process the
              voucher.";
         }
       } // end voucher
     } // end voucher-grouping
   }
   if we look at:
   [28]https://tools.ietf.org/html/rfc4108#section-1
   Notes on alternative approach:
       * short lifetimes with clean/simple renewal
       * renewal doesn't require repeating the "claim" process
       * might not even require authentication
       * all renewal's are added to the logs
    Hence, there is no need for revocation because the same use cases can be met.
     *  Name: long lived "claim" to a device with short term validity period for any given voucher. (basically what OCSP would provide)
     *

   To do this: [ACTION: MAX TO INSERT THIS INTO BRSKI]
     * Almost as an aside we realize that the MASA pki infrastructure can't easily do revocation either. Therefore:
     * MASA pki MUST/SHOULD use HSMs and be very protective of certs issued. Short lifetimes etc.

   a) Registrar claim's device and obtains a voucher.
     *  (netconf is outside of scope: assume web sales channel integration with emailed vouchers)
     * This is a 'short lifetime' voucher w/ Validity=RTC
     * Whatever 'claim' authentication process that is in place is used.
     * [QUESTION: Does the ACME "account" model inform us? No text, prepare for IETF discussion]
     * [29]https://tools.ietf.org/html/draft-ietf-acme-acme-05
     *

   b) Registrar's can request an updated voucher at any time
     *  (netconf is outside of scope: web site integration page with emailed vouchers *the the old address* (but it doesn't matter))
     * BRSKI by simply re-requesting a voucher using the existing REST interface. Submit the old (expired) voucher instead of a voucher request.
     * [MAX: normative statement about Registrar doing this and MASA behavior]
     *

   c) Registrars can go back to (a) at any time. For example if their domainID has changed.
     * [MAX: add this as a note. Nothing blocking it in the current draft].
     *

   Voucher draft:

   Remove most of Section 3 and replace (in Design Consideration) with a summary of the a,b,c above. Short lifetime vouchers with an easy path to request a new voucher. Where "easy" == if the domainID hasn't changed don't need to repeat hard claim process.
   section 4: remove final paragraph ("While it may make sense...")
   Add:
       if the domainID is compromised; then any outstanding voucher (that refs that domainID) could be used by the attacker.
       owner might be wise enough to go the CA and revoke the domainID certificate
       but they pledge might not check for revocation; so outstanding vouchers (or newly issued vouchers) could be used by the attacker
       to mitigate:
           owner should tell MASA... but also more flexible:
           MASA should check for expiration/revocation of of the trusted_ca_certificate when issuing voucher
   section 5.1: each instance of "revocation" becomes "blocking renewal" and all the logic is the same.
   section 6.1: remove "and revocations"
     *
     *

   3-14 pie day!
   attendees: max, kent, mcr, m.behringer joined 15 min late, nobody left on call?
   Voucher Request:

   What will the interop test suite look like?
   Run these entities:
     * MASA
     * Registrar
     * Pledge

   Message parsing:
     * Similar Makefile test suite in the zero-conf github
     * Proposes building up the pkcs7's etc via these methods
     * Confirm message generation and consumption
     * THIS IS PRIMARY (MCR, KENT are prepared for this)

   Protocols:

     * BRSKI sans discovery

     * static config of Registrar and MASA URLs

     BRSKI sans proxy
     * Pledge<->Registrar<->MASA

   Use cases to test:
     * vendorA Pledge

     * Can pledge parse a voucher from vendorA
     * (should be trivial)
     * (perhaps worth testing if a modified voucher is rejected)**

     vendorB Registrar

     * Can Registrar parse a voucher from vendorA
     * (likely the critical test)**

     vendorA MASA

     * Can MASA parse a request from vendorB
     * (likely a critical test)**

   What messages (JSON discrepencies)


   From BRSKI:
      {
      "version":"1",
      "nonce":"<64bit nonce value>",
      "IDevIDAuthorityKeyIdentifier":"<base64 encoded keyIdentifier">,
      "DevIDSerialNumber":"<id-at-serialNumber or base64 encoded
      hardwareModuleName hwSerialNum>",
      }
     *

   ===== preso for monday?
     * we need to request a preso for monday: MAX
     * 1) hackathon report (sat & sun results)
     * 2) updated docs summaryh

     * voucher doc (!!)
     * revocation resolution (DISCUSS items)
     * move to JWT.. what does this mean?
     * BRSKI doc
     *

   ***************************************
   2017-03-21 (well post pie day; you should have eaten it all by now)
   attendees: mcr, kent,max (joining now) here still eating week-old pie ;)
       NOTE: the meeting time is messed up because of daylight savings in the US messing with clocks.
       Max was here at the "same time" by a US clock but of course couldn't join the webex and looks like nobody else joined the etherpad
     *     "I'll try back in an hour" -- said he.
     *
     * hi. I was late.
     * anyone still here?
     *
     * 10:20, nobody here?
     * so, you can do this at 11am. okay.
     * back at 11am. fetching drink.
     *
     * Worked on slides for IETF98.
     *
     *
     *
     * hi. i'm around.
     * JOining the main webex.
     *

   ***************************************
   2017-03-25: kent
     *
     *
     * Hackathon Notes / Issues
     *
     * 1) Tag "authority key identifier" values with the which entity it refers to. For example does it refer to the MASA or the Registrar 'authority'
     *
     * 2) example in BRSKI doesn't match Yang of voucher doc. (NOTE: it does include authority info)
     *
     * 3) if we indirectly link the owner via the 'domain-certificate-identifier' then audit logs don't work?

     * CONCLUSION: add to the audit log (and audit log response) the registrarID
     * in this way we can distinguish between distinct registrars at a common public CA
     *

     4) Enumeration attack against the MASA audit log is not protected against
     * The DoS attack protection doesn't prevent this. A 'slow loris' attack would be possible.
     * - MASA can prevent using sales channel integration (to the currently defined BRSKI interface)

     * for example: a symetric key on a 2d barcode that is submitted to a REST interface
     * this is equivalent to the ACME model that where "domain validation" is "out of band" of the main protocol exchange

     - Proof-of-90ownership: interesting extensions to nonce's could provide some protections (but wouldn't prevent replay attacks? MASA server would have to watch for repeat nonces?)

     - there can be a time of purchase sales/channel integration (record that you purchased it)

     - add "proof-of-device-posession" would solve this at the cost of additional crypto operations and handshakes
     * (possible optimization: registrar inserts a "MASAnonce" into the handshake and then shares the handshake with the MASA server. Ideally w/o changes to the pledge behavior. Perhaps prepare for this by defining the TLS handshake extension that the Pledge MUST support but MAY ignore.)


     5) Pledge and Registrar (really all) SHOULD be tolerant (ignore) PEM headers around base64 encoded certificates?
     * Base64 decoding SHOULD be tolerant (ignore) line breaks and white space.
     * Is there a normative reference for this that we can point to to ensure this works?

     * 6) The Pledge voucher response validation needs to explicitely state that the nonce MAY be empty (removed by the Registrar).

     * 7) In the nonce-less voucher request clarify that the MASA must:

     * * authenticate the client using authentication (using "explicit or implicit (via RFC6125 reference identifiers that is certified by a well known, installed by default, trust anchor such as a CA browser forum)" validation, see EST).
     *  and
     * * SHOULD add the entire certificate chain to the audit database (this does not include a requirement to add
     * the full chain to the audit log).
     *

     8) strip all example vouchers from BRSKI - it is all done by reference to the voucher draft
     * 9) why IDevIDAuthorityKeyIdentifier is included is not specified in the BRSKI text
     *
     * 10) the CMS must be created with attributes
     *
     * 11) MASA processing instructions on how to determine the maximum voucher validity period (namely not longer than any of the revocation or ocsp validity periods that it verified when authenticating the domain registrar; assuming registrar authentication of course)

     *

     12) Clarify that the voucher request is just anything that is parsable as a voucher

     according to the voucher document. every single field in it is a *request* by the registrar

     and the server MUST NOT simply sign the request and return it. The MASA MAY read the values

     in the request to inform the MASA of policy requests by the client.


     13) Lucky 13! This is actually from discussion as per Michael B's presentation: He asks that the BRSKI state machine discussion is

     consistent with his anima-reference-model-03 slides as presented

     and asked here.
     *

   How to delete extraneous text:
       - dramatically
       - maybe by creating a design consideration into the appendix and moving lots of text to there
       - first pass: move (most) everything except protocol details and security considerations to an appendix. Move all normative statements to the protocol details section.

     *
     *
     * HERE is a voucher from mcr: [30]http://www.sandelman.ca/tmp/almec_voucher.smime
     * NOtes on this voucher:

     * signed by the CA cert. needs to be an RA (issued with a cmcRA key usage)
     * it has \n all through the owner cert.


   Notes on next step for hackathon:
   BRSKIEtherpad
   Sneakernet-BRSKI:
           [here is a voucher request]
   BRSKI: voucher request includes:
           - trusted-ca-certificate (eq TLS root cert)
                   included in voucher request; not in handshake because TLS excludes it
           - provide the Registrar CA cert and cmc-RA cert (eq TLS client cert)
                   (can be included in TLS hanshake)
                   but we don't do client-auth because it is required for smime anyway
                   meaning it is in the request
           - serial number (eq protocol data)
   Registrar:
           - offline insert of voucher from MASA
           - verify voucher signature
           - properly extract/report on devid serial number
           - verify that *my* ca cert is in the voucher
                   (it will result in the pledge trusting me!!)
           - set the MASA "MASAServerCert"
   Voucher Response:
           - trusted-ca-certificate (eq TLS root cert)
                   this provides the pledge with the CA cert so it can authenticate
                   the registrar (which till now was only provisionally authenticated)
           (other fields)

   2017-04-18:
     *     present: mcr

     * URL for connection: [31]https://appear.in/anima-boostrap
     * max will be there in a moment.
     *

   issues I have with concise document:
          DomainID:  The domain identity is the 160-bit SHA-1 hash of the BIT
         STRING of the subjectPublicKey of the domain trust anchor that is
         stored by the Domain CA.  This is consistent with the
         Certification Authority subject key identifier (Section 4.2.1.2
         [RFC5280]) of the Domain CA's self signed root certificate.  (A
         string value bound to the Domain CA's self signed root certificate
         subject and issuer fields is often colloquially used as a
         humanized identity value but during protocol discussions the more
         exact term as defined here is used).

       ^^^ I think the terminology section shouldn't say this, because we should it later.  MCR will edit/provide text.

       Discussion of what the concise rework in original document is.

       Onwards to vouchers:
   1. discussion about move to JWT...   [32]https://www.ietf.org/mail-archive/web/anima-bootstrap/current/msg00486.html
   To experiment I used "libjwt" from github as referenced by [33]https://jwt.io
   I built a "voucher-jwt" executable which produces:

   DUMP but not encoded:
   {
      "typ": "JWT",
      "alg": "ES256",
      "x5c":
   ["MIIBdjCCAR2gAwIBAgIBATAKBggqhkjOPQQDAjArMRYwFAYDVQQKDA1DaXNjbyBTeXN0ZW1zMREwDwYDVQQDDAhWZW5kb3JDQTAeFw0xNzA0MDMxNTE1NDVaFw0xODA0MDMxNTE1NDVaMC0xFjAUBgNVBAoMDUNpc2NvIFN5c3RlbXMxEzARBgNVBAMMClZlbmRvck1BU0EwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAT9GTrDd0GWgwcuSy8LCn0waMeknpLznajZzqWlLhrPwshgIPIPv
   byY6IyCo4uBYU/e4OO6TQD9UVLlyU5R6cA6ozAwLjALBgNVHQ8EBAMCBaAwHwYDVR0jBBgwFoAUR4oEpb4YFuelkMrQjlnKtM01ovEwCgYIKoZIzj0EAwIDRwAwRAIgAQ8YR2IdLodEE8k+JxpBOIAGuzCeT9BmFOVhFUb8eJMCIC23Goss6manRjNSmh6+2oB9tsRbjmnnwuMlDXR8fzug",
   "MIIBnTCCAUOgAwIBAgIJAK9Pd5G+/r0UMAoGCCqGSM49BAMCMCsxFjAUBgNVBAoMDUNpc2NvIFN5c3RlbXMxETAPBgNVBAMMCFZlbmRvckNBMB4XDTE3MDQwMzE0MTAwNVoXDTE4MDQwMzE0MTAwNVowKzEWMBQGA1UECgwNQ2lzY28gU3lzdGVtczERMA8GA1UEAwwIVmVuZG9yQ0EwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASunsQL2PVOSFWWp0oCjlqF8iVPPpEgJct931CZQ6assp
   07otmfgZqXsk1JYRTlKCGjROxrAiVRQsB54ioA0yu0o1AwTjAdBgNVHQ4EFgQUR4oEpb4YFuelkMrQjlnKtM01ovEwHwYDVR0jBBgwFoAUR4oEpb4YFuelkMrQjlnKtM01ovEwDAYDVR0TBAUwAwEB/zAKBggqhkjOPQQDAgNIADBFAiEA+SSOhiNQ23RWA76kZ/2u70FCpU8OsU7X9IRiWGDgIAgCIFLu8FnJuqPx10sgHvIzqI5BgOcwCa5vFQZdCDBHIx18"]
   }
   .  "compact serialization" [34]https://tools.ietf.org/html/rfc7515#section-7.1
   {
      "ietf-voucher:voucher": {
          "assertion": "logging",
          "domain-cert-trusted-ca": "-----BEGIN
   CERTIFICATE-----\nMIIBUjCB+qADAgECAgkAwP4qKsGyQlYwCgYIKoZIzj0EAwIwFzEVMBMGA1UEAwwM\nZXN0RXhhbXBsZUNBMB4XDTE3MDMyNTIyMTc1MFoXDTE4MDMyNTIyMTc1MFowFzEV\nMBMGA1UEAwwMZXN0RXhhbXBsZUNBMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE\nRVrNlEN2ocYscAILBU7NggABo0JgA1rEGdYdCQj1nHKL6xKONJIUfBibe6iMVYd3\nRUmPwaPiH
   NZJ98kRwHIwnKMvMC0wDAYDVR0TBAUwAwEB/zAdBgNVHQ4EFgQU+dVX\naXoucU1godNF0bycS1U5W54wCgYIKoZIzj0EAwIDRwAwRAIgNsCGjpEjuvz6OKJ/\n3rOvMc2ZfDhD02K+0PCVFJGCQGwCIAzf3BS6x9kKSROJJvxDSpg0QK9+b9LSFkbZ\nM1PW98AN\n-----END CERTIFICATE-----\n",
          "nonce": "ea7102e8e88f119e",
          "serial-number": "PID:1 SN:widget1",
          "serial-number-issuer": "36097E3DEA39316EA4CE5C695BE905E78AF2FB5A",
          "version": "1"
      }
   }
   ENCODED:
   eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiIsICAgICJ4NWMiOlsiTUlJQmRqQ0NBUjJnQXdJQkFnSUJBVEFLQmdncWhrak9QUVFEQWpBck1SWXdGQVlEVlFRS0RBMURhWE5qYnlCVGVYTjBaVzF6TVJFd0R3WURWUVFEREFoV1pXNWtiM0pEUVRBZUZ3MHhOekEwTURNeE5URTFORFZhRncweE9EQTBNRE14TlRFMU5EVmFNQzB4RmpBVUJnTlZCQW9NRFVOcGMyTnZJRk41YzNSbGJYTXhFekF
   SQmdOVkJBTU1DbFpsYm1SdmNrMUJVMEV3V1RBVEJnY3Foa2pPUFFJQkJnZ3Foa2pPUFFNQkJ3TkNBQVQ5R1RyRGQwR1dnd2N1U3k4TENuMHdhTWVrbnBMem5halp6cVdsTGhyUHdzaGdJUElQdmJ5WTZJeUNvNHVCWVUvZTRPTzZUUUQ5VVZMbHlVNVI2Y0E2b3pBd0xqQUxCZ05WSFE4RUJBTUNCYUF3SHdZRFZSMGpCQmd3Rm9BVVI0b0VwYjRZRnVlbGtNclFqbG5LdE0wMW92RXdDZ1lJS2
   9aSXpqMEVBd0lEUndBd1JBSWdBUThZUjJJZExvZEVFOGsrSnhwQk9JQUd1ekNlVDlCbUZPVmhGVWI4ZUpNQ0lDMjNHb3NzNm1hblJqTlNtaDYrMm9COXRzUmJqbW5ud3VNbERYUjhmenVnIiwiTUlJQm5UQ0NBVU9nQXdJQkFnSUpBSzlQZDVHKy9yMFVNQW9HQ0NxR1NNNDlCQU1DTUNzeEZqQVVCZ05WQkFvTURVTnBjMk52SUZONWMzUmxiWE14RVRBUEJnTlZCQU1NQ0ZabGJtUnZja05CT
   UI0WERURTNNRFF3TXpFME1UQXdOVm9YRFRFNE1EUXdNekUwTVRBd05Wb3dLekVXTUJRR0ExVUVDZ3dOUTJselkyOGdVM2x6ZEdWdGN6RVJNQThHQTFVRUF3d0lWbVZ1Wkc5eVEwRXdXVEFUQmdjcWhrak9QUUlCQmdncWhrak9QUU1CQndOQ0FBU3Vuc1FMMlBWT1NGV1dwMG9DamxxRjhpVlBQcEVnSmN0OTMxQ1pRNmFzc3AwN290bWZnWnFYc2sxSllSVGxLQ0dqUk94ckFpVlJRc0I1NGlv
   QTB5dTBvMUF3VGpBZEJnTlZIUTRFRmdRVVI0b0VwYjRZRnVlbGtNclFqbG5LdE0wMW92RXdId1lEVlIwakJCZ3dGb0FVUjRvRXBiNFlGdWVsa01yUWpsbkt0TTAxb3ZFd0RBWURWUjBUQkFVd0F3RUIvekFLQmdncWhrak9QUVFEQWdOSUFEQkZBaUVBK1NTT2hpTlEyM1JXQTc2a1ovMnU3MEZDcFU4T3NVN1g5SVJpV0dEZ0lBZ0NJRkx1OEZuSnVxUHgxMHNnSHZJenFJNUJnT2N3Q2E1dkZ
   RWmRDREJISXgxOCJdfQ.eyJpZXRmLXZvdWNoZXI6dm91Y2hlciI6eyJhc3NlcnRpb24iOiJsb2dnaW5nIiwiZG9tYWluLWNlcnQtdHJ1c3RlZC1jYSI6Ii0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxuTUlJQlVqQ0IrcUFEQWdFQ0Fna0F3UDRxS3NHeVFsWXdDZ1lJS29aSXpqMEVBd0l3RnpFVk1CTUdBMVVFQXd3TVxuWlhOMFJYaGhiWEJzWlVOQk1CNFhEVEUzTURNeU5USXlNVGM
   xTUZvWERURTRNRE15TlRJeU1UYzFNRm93RnpFVlxuTUJNR0ExVUVBd3dNWlhOMFJYaGhiWEJzWlVOQk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRVxuUlZyTmxFTjJvY1lzY0FJTEJVN05nZ0FCbzBKZ0ExckVHZFlkQ1FqMW5IS0w2eEtPTkpJVWZCaWJlNmlNVllkM1xuUlVtUHdhUGlITlpKOThrUndISXduS012TUMwd
   0RBWURWUjBUQkFVd0F3RUIvekFkQmdOVkhRNEVGZ1FVK2RWWFxuYVhvdWNVMWdvZE5GMGJ5Y1MxVTVXNTR3Q2dZSUtvWkl6ajBFQXdJRFJ3QXdSQUlnTnNDR2pwRWp1dno2T0tKL1xuM3JPdk1jMlpmRGhEMDJLKzBQQ1ZGSkdDUUd3Q0lBemYzQlM2eDlrS1NST0pKdnhEU3BnMFFLOStiOUxTRmtiWlxuTTFQVzk4QU5cbi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cbiIsIm5vbmNlIjoi
   ZWE3MTAyZThlODhmMTE5ZSIsInNlcmlhbC1udW1iZXIiOiJQSUQ6MSBTTjp3aWRnZXQxIiwic2VyaWFsLW51bWJlci1pc3N1ZXIiOiIzNjA5N0UzREVBMzkzMTZFQTRDRTVDNjk1QkU5MDVFNzhBRjJGQjVBIiwidmVyc2lvbiI6IjEifX0.QkTUpcxv6Ng6ylyWYnlqun-5SFhD1XwLIW1kD7Y9dNwioheNMcVnowkELl_EMClyOWuLvvWuoCHAcWz_UA0IGw
   A "general JWS JSON Serialization" would look like:

       {
         "payload":"<payload contents>",
         "signatures":[
          {"protected":"<integrity-protected header 1 contents>",
           "header":<non-integrity-protected header 1 contents>,
           "signature":"<signature 1 contents>"},
          ...
          {"protected":"<integrity-protected header N contents>",
           "header":<non-integrity-protected header N contents>,
           "signature":"<signature N contents>"}]
        }
   a "flattened" form:
       {
         "payload":"<payload contents>",
         "protected":"<integrity-protected header contents>",
         "header":<non-integrity-protected header contents>,
         "signature":"<signature contents>"
        }


   Voucher Request Discussion:
   The BRSKI doc assumes a form of voucher request which could be summarized as a "not signed voucher template". Containing only the information known by the client.
   The Registrar then signs this and sends it to the MASA to be turned into a voucher.
   see [35]https://tools.ietf.org/html/draft-ietf-anima-bootstrapping-keyinfra-05#section-7.1
   A voucher request is a voucher that is not signed by the MASA.
   A voucher request MUST be signed by the Registrar. This is equivalent to the current pkcs7 signing mandate.
   A new thing: A voucher request MAY be signed by the Pledge.
     * con: additional crypto operation by the pledge
     * pro: proof to the masa of physical possession
     * An option to be discussed.

   Another new thing: A voucher MAY include a "previous form of the voucher request" sub-field. e.g. a JSON of the full previously signed voucher. e.g. we add to the YANG model a field that could be a full JSON etc voucher; which itself might have been signed. Thus:
   Pledge optionally signs the voucher request with a nonce in it.
   Registrar signs a voucher that includes the previous voucher.
     * {header/signature}.Pledge_voucher{nonce, etc}
     * {header/signature}.Registrar_voucher{copy some fields, added some fields, {header/signature}.Pledge_voucher{nonce, etc}}
     * this would be the JSON Compact Serialization URL-safe string. something like a string value.

   MASA recieves and creates a voucher (dropping all previous requests).
   Need to define: what does the Registrar do with this? Can't always include it because it could include fields the Registrar doesn't know. MAY/SHOUDL include it for the MASA to make policy decisions.
   SIDE NOTE: verification of the TLS client cert as being the same as the voucher request might be(!?) assumed in the current 7.2 text. Two reasons for this:
     * - we avoid having to deal with replay attacks
     * - and the domain CA cert isn't sent in the TLS handshake but is sent in the signature header ("pkcs7" or "x5c").

   This is an issue regardless of the format discussion.
   Perhaps all that matters is that the root is the same but not that they are the same certificate?
   2017-04-25:
     *     present: mcr, peter, mbehringer, kent looking for correct webex...  Didn't work for me.
     * webex is dead to me:  [36]https://appear.in/anima-boostrap I'm in.
     * Michael Behringer... you joining? trying hard. I'm in the appear in room, I THINK. But can't see anyone else?  You mistyped the URL. no 't' my gosh....
     *
     * {mcr still way behind; was ill last week}
     *

   brief recap by mcr, about what we did last week.
   Max: recap of list is that we need a definitive form for the voucher request.... "it's just a voucher" ,
   Kent: related, but slightly different format.
   Max: signed certificate requests mean that the registrar can not change it, and this has caused a mess.
   mcr asks for details... max: lack of interoperation.
   To fix the syntax from 1357:

   voucher request
   {
       "header": "foo"
   }
   .
   {
     *     payload" : "bar"

   }
   .signature
   {
       "header": "foo"
   }
   .
   {
     * payload" : "bar",
     * prior_jwt : "{h}.{p,prior_jwt:"<base64>"}.s"

   }
   .signature
   Max's proposed algorithm for signing vouchers is:
     * The relying party validates and signs the "first" voucher in the list
     * The relying party MAY recurse into the list to verify, for example, that the inner jwt was signed by the pledge

     * Processing is effectively this:
     * recurse to the bottom of the list. Built a json from the payload. As you return up the list re-apply each JSON payload.

     * Has the disadvantage of making it difficult to remove something.

     each node copies what it want to maintain. the optional history list is purely informative. <----- BEST
     *

   DIAGRAM OF ACTORS:
                                      CMS
       [MASA] <--A--> [ REGISTRAR ] <--C--> [ CERTAUTHORITY ]
               voucher  \
               proto      \B  [BRSKI/EST]
                            \
                              [PLEDGE]
   handling criticality:
       [37]https://tools.ietf.org/html/rfc7515#section-4.1.11
        {"alg":"ES256",
         "crit":["exp"],
         "exp":1363284000
        }
   [38]https://tools.ietf.org/html/rfc7951 (yang-json)
   [39]https://datatracker.ietf.org/doc/draft-ietf-core-yang-cbor/ (yang to cbor)
   [40]https://tools.ietf.org/html/rfc7950#section-11 (updating a yang module)
      o  A "mandatory" statement may be removed or changed from "true" to
         "false".

   ACTION:
     * 1) add version field to the voucher
     * 2) define voucher request in BRSKI (as a voucher)
     * 3) define any additional fields in BRSKI:

     *


   module ietf-voucher-req {
     import ietf-vouher {
       prefix v;
     }

     augment "v:voucher/" {
         leaf prior_signedvoucher {
             type binary;
             description
                "...";
         }
   }
     *

   2017-05-02
     * present: mcr, Michael Behringer
     *
     * suggest we go through EDNOTEs in document.
     *
     *    [[EDNOTE: move below?]]The Pledge establishes a TLS connection with
     *     ---> agreed
     * [41]https://github.com/anima-wg/anima-bootstrap/blob/concise/dtbootstrap-anima-keyinfra.txt
     *
     * Is there a relationship between the TLS Server Certificate of the MASA, and the Issuer Certificate from the IDevID.
     * Cases:
     *  - pledge contains URL of MASA
     *  - step 1: registrar follows URL (default)
     *  - option 1: redirect: should it be allowed? (if not, cannot deploy anti-DDOS re-direct)
     *  - option 2: manual override of URL: should it be allowed?
     * Tentatively: Neither option 1 or 2 have an impact on security ("stealing" a device).
     * HTTP/2, TLS upgrade.
     * Can/should the registrar connect to MASA, online to the TLS connection to the Pledge, to get the certificate chain to validate the pledge?
     * {is there an attack on the Registrar by the pledge,
     * MB suggests that[DEL: IDevID and :DEL] MASA Server Certificate would be verifiable via the WebPKI, and there would not necessarily be any common root of trust between the two.
     *
     * There are two security associations:
     * - between pledge and MASA
     * - between Registrar and MASA
     * Observations:
     * - those two SAs are independent
     * - the first (BRSKI/EST) is anchored on a trust anchor that may be private (ie not part of the public PKI)
     * - the second (MASA<->Registrar) is normally anchored on the public WebPKI for the ServerCertificate.
     * - the URL in the certificate of the IDevID of the pledge may be used to point the registrar to the MASA. (or, redirect, or override, see line 1477-1478)
     *   --> In that URL, the vendor defines the type of security association to be used between registrar and MASA.
     *   --> The vendor choooses the type of SA. MUST define a minimum protocol set that MUST be supported on the registrar, including a minimum level of security.
     *
     *
     *
     *
     *

   [42]JavaScript license information

References

   1. https://trac.tools.ietf.org/wg/anima/trac/wiki/Bootstrap
   2. https://tools.ietf.org/html/draft-ietf-anima-bootstrapping-keyinfra-04
   3. https://tools.ietf.org/html/draft-vanderstok-core-coap-est-00#section-3.1
   4. https://github.com/anima-wg
   5. https://ietf.webex.com/ietf/j.php?MTID=m00a039327e09fc09340872992b151581
   6. https://tools.ietf.org/html/draft-kwatsen-anima-voucher-00
   7. https://www.certificate-transparency.org/how-ct-works
   8. https://datatracker.ietf.org/wg/cose/documents/
   9. https://tools.ietf.org/html/rfc7030#section-5
  10. https://cisco.webex.com/join/pritikin
  11. https://tools.ietf.org/html/draft-ietf-anima-bootstrapping-keyinfra-04
  12. https://www.iana.org/assignments/media-types/media-types.xml
  13. https://tools.ietf.org/html/draft-ietf-netconf-restconf-12#section-3.1
  14. https://tools.ietf.org/html/rfc5785
  15. https://www.ietf.org/hackathon/98-hackathon.html)
  16. http://www.sandelman.ca/SSW/ietf/6tisch/
  17. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After
  18. https://github.com/anima-wg/anima-bootstrap/commit/bba6351458955862965c71199b2f8a94f90cf169
  19. https://github.com/anima-wg/anima-bootstrap/commit/e049ec790a7051d54094bfca9d8921e59d7458e5
  20. https://stackoverflow.com/questions/39909419/jwt-vs-oauth-authentication
  21. http://tools.ietf.org/wg/anima/
  22. mailto:anima@ietf.org
  23. mailto:kwatsen@juniper.net
  24. mailto:pritikin@cisco.com
  25. mailto:mcr+ietf@sandelman.ca
  26. https://tools.ietf.org/html/rfc5652#section-10.2.1
  27. https://tools.ietf.org/html/rfc6960#section-3.1
  28. https://tools.ietf.org/html/rfc4108#section-1
  29. https://tools.ietf.org/html/draft-ietf-acme-acme-05
  30. http://www.sandelman.ca/tmp/almec_voucher.smime
  31. https://appear.in/anima-boostrap
  32. https://www.ietf.org/mail-archive/web/anima-bootstrap/current/msg00486.html
  33. https://jwt.io/
  34. https://tools.ietf.org/html/rfc7515#section-7.1
  35. https://tools.ietf.org/html/draft-ietf-anima-bootstrapping-keyinfra-05#section-7.1
  36. https://appear.in/anima-boostrap
  37. https://tools.ietf.org/html/rfc7515#section-4.1.11
  38. https://tools.ietf.org/html/rfc7951
  39. https://datatracker.ietf.org/doc/draft-ietf-core-yang-cbor/
  40. https://tools.ietf.org/html/rfc7950#section-11
  41. https://github.com/anima-wg/anima-bootstrap/blob/concise/dtbootstrap-anima-keyinfra.txt
  42. file://localhost/javascript
