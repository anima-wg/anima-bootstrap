<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Bootstrapping Remote Secure Key Infrastructures (BRSKI)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Other Bootstrapping Approaches"/>
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Terminology"/>
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Scope of solution"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Architectural Overview"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Secure Imprinting using Vouchers"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Initial Device Identifier"/>
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Protocol Flow"/>
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Lack of realtime clock"/>
<link href="#rfc.section.2.5" rel="Chapter" title="2.5 Cloud Registrar"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Protocol Details"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Discovery"/>
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Proxy Discovery Protocol Details"/>
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Registrar Discovery Protocol Details"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Request Voucher from the Registrar"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Request Voucher from MASA"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Voucher Response"/>
<link href="#rfc.section.3.4.1" rel="Chapter" title="3.4.1 Completing authentication of Provisional TLS connection"/>
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Voucher Status Telemetry"/>
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 MASA authorization log Request"/>
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 MASA authorization log Response"/>
<link href="#rfc.section.3.8" rel="Chapter" title="3.8 EST Integration for PKI bootstrapping"/>
<link href="#rfc.section.3.8.1" rel="Chapter" title="3.8.1 EST Distribution of CA Certificates"/>
<link href="#rfc.section.3.8.2" rel="Chapter" title="3.8.2 EST CSR Attributes"/>
<link href="#rfc.section.3.8.3" rel="Chapter" title="3.8.3 EST Client Certificate Request"/>
<link href="#rfc.section.3.8.4" rel="Chapter" title="3.8.4 Enrollment Status Telemetry"/>
<link href="#rfc.section.3.8.5" rel="Chapter" title="3.8.5 EST over CoAP"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Reduced security operational modes"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Trust Model"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Pledge security reductions"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Registrar security reductions"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 MASA security reductions"/>
<link href="#rfc.section.5" rel="Chapter" title="5 IANA Considerations"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 PKIX Registry"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="8 References"/>
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A IPv4 operations"/>
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 IPv4 Link Local addresses"/>
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Use of DHCPv4"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B mDNS / DNSSD proxy discovery options"/>
<link href="#rfc.appendix.C" rel="Chapter" title="C IPIP Join Proxy mechanism"/>
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Multiple Join networks on the Join Proxy side"/>
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Automatic configuration of tunnels on Registrar"/>
<link href="#rfc.appendix.C.3" rel="Chapter" title="C.3 Proxy Neighbor Discovery by Join Proxy"/>
<link href="#rfc.appendix.C.4" rel="Chapter" title="C.4 Use of connected sockets; or IP_PKTINFO for CoAP on Registrar"/>
<link href="#rfc.appendix.C.5" rel="Chapter" title="C.5 Use of socket extension rather than virtual interface"/>
<link href="#rfc.appendix.D" rel="Chapter" title="D To be deprecated: Consolidation remnants"/>
<link href="#rfc.appendix.D.1" rel="Chapter" title="D.1 Functional Overview"/>
<link href="#rfc.appendix.D.1.1" rel="Chapter" title="D.1.1 Behavior of a Pledge"/>
<link href="#rfc.appendix.D.1.2" rel="Chapter" title="D.1.2 Behavior of a Join Proxy"/>
<link href="#rfc.appendix.D.1.3" rel="Chapter" title="D.1.3 Behavior of the Registrar"/>
<link href="#rfc.appendix.D.1.4" rel="Chapter" title="D.1.4 Behavior of the MASA Service"/>
<link href="#rfc.appendix.D.1.5" rel="Chapter" title="D.1.5 Leveraging the new key infrastructure / next steps"/>
<link href="#rfc.appendix.D.1.6" rel="Chapter" title="D.1.6 Interactions with Network Access Control"/>
<link href="#rfc.appendix.D.2" rel="Chapter" title="D.2 Domain Operator Activities"/>
<link href="#rfc.appendix.D.2.1" rel="Chapter" title="D.2.1 Instantiating the Domain Certification Authority"/>
<link href="#rfc.appendix.D.2.2" rel="Chapter" title="D.2.2 Instantiating the Registrar"/>
<link href="#rfc.appendix.D.2.3" rel="Chapter" title="D.2.3 Accepting New Entities"/>
<link href="#rfc.appendix.D.2.4" rel="Chapter" title="D.2.4 Automatic Enrollment of Devices"/>
<link href="#rfc.appendix.D.2.5" rel="Chapter" title="D.2.5 Secure Network Operations"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Pritikin, M., Richardson, M., Behringer, M., Bjarnason, S., and K. Watsen" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-anima-bootstrapping-keyinfra-07" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-7-2" />
  <meta name="dct.abstract" content="This document specifies automated bootstrapping of a remote secure key infrastructure (BRSKI) using vendor installed X.509 certificate, in combination with a vendor's authorizing service, both online and offline.  Bootstrapping a new device can occur using a routable address and a cloud service, or using only link-local connectivity, or on limited/disconnected networks. Support for lower security models, including devices with minimal identity, is described for legacy reasons but not encouraged. Bootstrapping is complete when the cryptographic identity of the new key infrastructure is successfully deployed to the device but the established secure connection can be used to deploy a locally issued certificate to the device as well." />
  <meta name="description" content="This document specifies automated bootstrapping of a remote secure key infrastructure (BRSKI) using vendor installed X.509 certificate, in combination with a vendor's authorizing service, both online and offline.  Bootstrapping a new device can occur using a routable address and a cloud service, or using only link-local connectivity, or on limited/disconnected networks. Support for lower security models, including devices with minimal identity, is described for legacy reasons but not encouraged. Bootstrapping is complete when the cryptographic identity of the new key infrastructure is successfully deployed to the device but the established secure connection can be used to deploy a locally issued certificate to the device as well." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">ANIMA WG</td>
  <td class="right">M. Pritikin</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Cisco</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">M. Richardson</td>
</tr>
<tr>
  <td class="left">Expires: January 3, 2018</td>
  <td class="right">SSW</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">M. Behringer</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">S. Bjarnason</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">Cisco</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">K. Watsen</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">Juniper Networks</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">July 2, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Bootstrapping Remote Secure Key Infrastructures (BRSKI)<br />
  <span class="filename">draft-ietf-anima-bootstrapping-keyinfra-07</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document specifies automated bootstrapping of a remote secure key infrastructure (BRSKI) using vendor installed X.509 certificate, in combination with a vendor's authorizing service, both online and offline.  Bootstrapping a new device can occur using a routable address and a cloud service, or using only link-local connectivity, or on limited/disconnected networks. Support for lower security models, including devices with minimal identity, is described for legacy reasons but not encouraged. Bootstrapping is complete when the cryptographic identity of the new key infrastructure is successfully deployed to the device but the established secure connection can be used to deploy a locally issued certificate to the device as well.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 3, 2018.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Other Bootstrapping Approaches</a></li>
<li>1.2.   <a href="#rfc.section.1.2">Terminology</a></li>
<li>1.3.   <a href="#rfc.section.1.3">Scope of solution</a></li>
</ul><li>2.   <a href="#rfc.section.2">Architectural Overview</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Secure Imprinting using Vouchers</a></li>
<li>2.2.   <a href="#rfc.section.2.2">Initial Device Identifier</a></li>
<li>2.3.   <a href="#rfc.section.2.3">Protocol Flow</a></li>
<li>2.4.   <a href="#rfc.section.2.4">Lack of realtime clock</a></li>
<li>2.5.   <a href="#rfc.section.2.5">Cloud Registrar</a></li>
</ul><li>3.   <a href="#rfc.section.3">Protocol Details</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Discovery</a></li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">Proxy Discovery Protocol Details</a></li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Registrar Discovery Protocol Details</a></li>
</ul><li>3.2.   <a href="#rfc.section.3.2">Request Voucher from the Registrar</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Request Voucher from MASA</a></li>
<li>3.4.   <a href="#rfc.section.3.4">Voucher Response</a></li>
<ul><li>3.4.1.   <a href="#rfc.section.3.4.1">Completing authentication of Provisional TLS connection</a></li>
</ul><li>3.5.   <a href="#rfc.section.3.5">Voucher Status Telemetry</a></li>
<li>3.6.   <a href="#rfc.section.3.6">MASA authorization log Request</a></li>
<li>3.7.   <a href="#rfc.section.3.7">MASA authorization log Response</a></li>
<li>3.8.   <a href="#rfc.section.3.8">EST Integration for PKI bootstrapping</a></li>
<ul><li>3.8.1.   <a href="#rfc.section.3.8.1">EST Distribution of CA Certificates</a></li>
<li>3.8.2.   <a href="#rfc.section.3.8.2">EST CSR Attributes</a></li>
<li>3.8.3.   <a href="#rfc.section.3.8.3">EST Client Certificate Request</a></li>
<li>3.8.4.   <a href="#rfc.section.3.8.4">Enrollment Status Telemetry</a></li>
<li>3.8.5.   <a href="#rfc.section.3.8.5">EST over CoAP</a></li>
</ul></ul><li>4.   <a href="#rfc.section.4">Reduced security operational modes</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Trust Model</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Pledge security reductions</a></li>
<li>4.3.   <a href="#rfc.section.4.3">Registrar security reductions</a></li>
<li>4.4.   <a href="#rfc.section.4.4">MASA security reductions</a></li>
</ul><li>5.   <a href="#rfc.section.5">IANA Considerations</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">PKIX Registry</a></li>
</ul><li>6.   <a href="#rfc.section.6">Security Considerations</a></li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a></li>
<li>8.   <a href="#rfc.references">References</a></li>
<ul><li>8.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">IPv4 operations</a></li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">IPv4 Link Local addresses</a></li>
<li>A.2.   <a href="#rfc.appendix.A.2">Use of DHCPv4</a></li>
</ul><li>Appendix B.   <a href="#rfc.appendix.B">mDNS / DNSSD proxy discovery options</a></li>
<li>Appendix C.   <a href="#rfc.appendix.C">IPIP Join Proxy mechanism</a></li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Multiple Join networks on the Join Proxy side</a></li>
<li>C.2.   <a href="#rfc.appendix.C.2">Automatic configuration of tunnels on Registrar</a></li>
<li>C.3.   <a href="#rfc.appendix.C.3">Proxy Neighbor Discovery by Join Proxy</a></li>
<li>C.4.   <a href="#rfc.appendix.C.4">Use of connected sockets; or IP_PKTINFO for CoAP on Registrar</a></li>
<li>C.5.   <a href="#rfc.appendix.C.5">Use of socket extension rather than virtual interface</a></li>
</ul><li>Appendix D.   <a href="#rfc.appendix.D">To be deprecated: Consolidation remnants</a></li>
<ul><li>D.1.   <a href="#rfc.appendix.D.1">Functional Overview</a></li>
<ul><li>D.1.1.   <a href="#rfc.appendix.D.1.1">Behavior of a Pledge</a></li>
<li>D.1.2.   <a href="#rfc.appendix.D.1.2">Behavior of a Join Proxy</a></li>
<li>D.1.3.   <a href="#rfc.appendix.D.1.3">Behavior of the Registrar</a></li>
<li>D.1.4.   <a href="#rfc.appendix.D.1.4">Behavior of the MASA Service</a></li>
<li>D.1.5.   <a href="#rfc.appendix.D.1.5">Leveraging the new key infrastructure / next steps</a></li>
<li>D.1.6.   <a href="#rfc.appendix.D.1.6">Interactions with Network Access Control</a></li>
</ul><li>D.2.   <a href="#rfc.appendix.D.2">Domain Operator Activities</a></li>
<ul><li>D.2.1.   <a href="#rfc.appendix.D.2.1">Instantiating the Domain Certification Authority</a></li>
<li>D.2.2.   <a href="#rfc.appendix.D.2.2">Instantiating the Registrar</a></li>
<li>D.2.3.   <a href="#rfc.appendix.D.2.3">Accepting New Entities</a></li>
<li>D.2.4.   <a href="#rfc.appendix.D.2.4">Automatic Enrollment of Devices</a></li>
<li>D.2.5.   <a href="#rfc.appendix.D.2.5">Secure Network Operations</a></li>
</ul></ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">BRSKI provides a foundation to securely answer the following questions between an element of the network domain called the "Registrar" and an unconfigured and untouched device called a "Pledge":</p>
<p/>

<ul>
  <li>Registrar authenticating the Pledge: "Who is this device? What is its identity?"</li>
  <li>Registrar authorization the Pledge: "Is it mine? Do I want it? What are the chances it has been compromised?"</li>
  <li>Pledge authenticating the Registrar/Domain: "What is this domain's identity?"</li>
  <li>Pledge authorization the Registrar: "Should I join it?"</li>
</ul>
<p id="rfc.section.1.p.3">This document details protocols and messages to the endpoints to answer the above questions. The Registrar actions derive from Pledge identity, third party cloud service communications, and local access control lists. The Pledge actions derive from a cryptographically protected "voucher" message delivered through the Registrar.</p>
<p id="rfc.section.1.p.4">The syntactic details of vouchers are described in detail in <a href="#I-D.ietf-anima-voucher">[I-D.ietf-anima-voucher]</a>. This document details automated protocol mechanisms to obtain vouchers.</p>
<p id="rfc.section.1.p.5">BRSKI results in the Pledge storing an X.509 root certificate sufficient for verifying the Registrar identity. In the process a TLS connection is established which can be directly used for Enrollment over Secure Transport (EST). The Pledge can use these credentials to secure additional protocol exchanges.</p>
<p id="rfc.section.1.p.6">BRSKI is agile enough to support bootstrapping alternative key infrastructures, such as a symmetric key solutions, but no such system is described in this document.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> Other Bootstrapping Approaches</h1>
<p id="rfc.section.1.1.p.1">To literally "pull yourself up by the bootstraps" is an impossible action. Similarly the secure establishment of a key infrastructure without external help is also an impossibility. Today it is commonly accepted that the initial connections between nodes are insecure, until key distribution is complete, or that domain-specific keying material is pre-provisioned on each new device in a costly and non-scalable manner. Existing mechanisms are known as non-secured 'Trust on First Use' (TOFU) <a href="#RFC7435">[RFC7435]</a>, 'resurrecting duckling' <a href="#Stajano99theresurrecting">[Stajano99theresurrecting]</a> or 'pre-staging'.</p>
<p id="rfc.section.1.1.p.2">Another approach is to try and minimize user actions during bootstrapping. The enrollment protocol EST <a href="#RFC7030">[RFC7030]</a> details a set of non-autonomic bootstrapping methods in this vein:</p>
<p/>

<ul>
  <li>using the Implicit Trust Anchor database (not an autonomic solution because the URL must be securely distributed),</li>
  <li>engaging a human user to authorize the CA certificate using out-of-band data (not an autonomic solution because the human user is involved),</li>
  <li>using a configured Explicit TA database (not an autonomic solution because the distribution of an explicit TA database is not autonomic),</li>
  <li>and using a Certificate-Less TLS mutual authentication method (not an autonomic solution because the distribution of symmetric key material is not autonomic).</li>
</ul>

<p>These "touch" methods do not meet the requirements for zero-touch.</p>
<p id="rfc.section.1.1.p.4">There are "call home" technologies where the Pledge first establishes a connection to a well known vendor service using a common client-server authentication model. After mutual authentication appropriate credentials to authenticate the target domain are transfered to the Pledge. This creates serveral problems and limitations:</p>
<p/>

<ul>
  <li>the pledge requires realtime connectivity to the vendor service,</li>
  <li>the domain identity is exposed to the vendor service (this is a privacy concern),</li>
  <li>the vendor is responsible for making the authorization decisions (this is a liability concern),</li>
</ul>
<p id="rfc.section.1.1.p.6">BRSKI addresses these issues by defining extensions to the EST protocol for the automated distribution of vouchers.  </p>
<h1 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> Terminology</h1>
<p id="rfc.section.1.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.1.2.p.2">The following terms are defined for clarity:</p>
<p/>

<dl>
  <dt>DomainID:</dt>
  <dd style="margin-left: 8">The domain identity is the 160-bit SHA-1 hash of the BIT STRING of the subjectPublicKey of the domain trust anchor that is stored by the Domain CA. This is consistent with the Certification Authority subject key identifier (<a href="#RFC5280">Section 4.2.1.2</a> <cite title="NONE">[RFC5280]</cite>) of the Domain CA's self signed root certificate. (A string value bound to the Domain CA's self signed root certificate subject and issuer fields is often colloquially used as a humanized identity value but during protocol discussions the more exact term as defined here is used).</dd>
  <dt>drop ship:</dt>
  <dd style="margin-left: 8">The physical distribution of equipment containing the "factory default" configuration to a final destination. In zero-touch scenarios there is no staging or pre-configuration during drop-ship.</dd>
  <dt>imprint:</dt>
  <dd style="margin-left: 8">The process where a device obtains the cryptographic key material to identify and trust future interactions with a network. This term is taken from Konrad Lorenz's work in biology with new ducklings: during a critical period, the duckling would assume that anything that looks like a mother duck is in fact their mother. An equivalent for a device is to obtain the fingerprint of the network's root certification authority certificate. A device that imprints on an attacker suffers a similar fate to a duckling that imprints on a hungry wolf. Securely imprinting is a primary focus of this document.<a href="#imprinting">[imprinting]</a>. The analogy to Lorenz's work was first noted in <a href="#Stajano99theresurrecting">[Stajano99theresurrecting]</a>.</dd>
  <dt>enrollment:</dt>
  <dd style="margin-left: 8">The process where a device presents key material to a network and acquires a network specific identity.  For example when a certificate signing request is presented to a certification authority and a certificate is obtained in response.</dd>
  <dt>Pledge:</dt>
  <dd style="margin-left: 8">The prospective device, which has an identity installed by a third-party (e.g., vendor, manufacturer or integrator).</dd>
  <dt>Voucher</dt>
  <dd style="margin-left: 8">A signed statement from the MASA service that indicates to a Pledge the cryptographic identity of the Registrar it should trust. There are different types of vouchers depending on how that trust asserted. Multiple voucher types are defined in <a href="#I-D.ietf-anima-voucher">[I-D.ietf-anima-voucher]</a></dd>
  <dt>Domain:</dt>
  <dd style="margin-left: 8">The set of entities that trust a common key infrastructure trust anchor. This includes the Proxy, Registrar, Domain Certificate Authority, Management components and any existing entity that is already a member of the domain.</dd>
  <dt>Domain CA:</dt>
  <dd style="margin-left: 8">The domain Certification Authority (CA) provides certification functionalities to the domain. At a minimum it provides certification functionalities to a Registrar and stores the trust anchor that defines the domain. Optionally, it certifies all elements.</dd>
  <dt>Join Registrar (and Coordinator):</dt>
  <dd style="margin-left: 8">A representative of the domain that is configured, perhaps autonomically, to decide whether a new device is allowed to join the domain. The administrator of the domain interfaces with a Join Registrar (and Coordinator) to control this process. Typically a Join Registrar is "inside" its domain. For simplicity this document often refers to this as just "Registrar". The term JRC is used in common with other bootstrap mechanisms.</dd>
  <dt>Join Proxy:</dt>
  <dd style="margin-left: 8">A domain entity that helps the pledge join the domain. A Proxy facilitates communication for devices that find themselves in an environment where they are not provided connectivity until after they are validated as members of the domain. The pledge is unaware that they are communicating with a proxy rather than directly with a Registrar.</dd>
  <dt>MASA Service:</dt>
  <dd style="margin-left: 8">A third-party Manufacturer Authorized Signing Authority (MASA) service on the global Internet. The MASA signs vouchers. It also provides a repository for audit log information of privacy protected bootstrapping events. It does not track ownership.</dd>
  <dt>Ownership Tracker:</dt>
  <dd style="margin-left: 8">An Ownership Tracker service on the global internet. The Ownership Tracker uses business processes to accurately track ownership of all devices shipped against domains that have purchased them. Although optional this component allows vendors to provide additional value in cases where their sales and distribution channels allow for accurately tracking of such ownership. Ownership tracking information is indicated in vouchers as described in <a href="#I-D.ietf-anima-voucher">[I-D.ietf-anima-voucher]</a></dd>
  <dt>IDevID:</dt>
  <dd style="margin-left: 8">An Initial Device Identity X.509 certificate installed by the vendor on new equipment.</dd>
  <dt>TOFU:</dt>
  <dd style="margin-left: 8">Trust on First Use. Used similarly to <a href="#RFC7435">[RFC7435]</a>. This is where a Pledge device makes no security decisions but rather simply trusts the first Registrar it is contacted by. This is also known as the "resurrecting duckling" model.</dd>
</dl>
<h1 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3.</a> Scope of solution</h1>
<p id="rfc.section.1.3.p.1">Questions have been posed as to whether this solution is suitable in general for Internet of Things (IoT) networks. This depends on the capabilities of the devices in question. The terminology of <a href="#RFC7228">[RFC7228]</a> is best used to describe the boundaries.</p>
<p id="rfc.section.1.3.p.2">The solution described in this document is aimed in general at non-constrained (i.e. class 2+) devices operating on a non-Challenged network. The entire solution as described here is not intended to be useable as-is by constrained devices operating on challenged networks (such as 802.15.4 LLNs).</p>
<p id="rfc.section.1.3.p.3">In many target applications, the systems involved are large router platforms with multi-gigabit inter-connections, mounted in controlled access data centers. But this solution is not exclusive to the large, it is intended to scale to thousands of devices located in hostile environments, such as ISP provided CPE devices which are drop-shipped to the end user. The situation where an order is fulfilled from distributed warehouse from a common stock and shipped directly to the target location at the request of the domain owner is explicitly supported. That stock ("SKU") could be provided to a number of potential domain owners, and the eventual domain owner will not know a-priori which device will go to which location.</p>
<p id="rfc.section.1.3.p.4">The bootstrapping process can take minutes to complete depending on the network infrastructure and device processing speed. The network communication itself is not optimized for speed; for privacy reasons, the discovery process allows for the Pledge to avoid announcing it's presence through broadcasting.  </p>
<p id="rfc.section.1.3.p.5">This protocol is not intended for low latency handoffs. In networks requiring such things, the pledge SHOULD already have been enrolled.  </p>
<p id="rfc.section.1.3.p.6">Specifically, there are protocol aspects described here which might result in congestion collapse or energy-exhaustion of intermediate battery powered routers in an LLN. Those types of networks SHOULD NOT use this solution. These limitations are predominately related to the large credential and key sizes required for device authentication.  Defining symmetric key techniques that meet the operational requirements is out-of-scope but the underlying protocol operations (TLS handshake and signing structures) have sufficient algorithm agility to support such techniques when defined.</p>
<p id="rfc.section.1.3.p.7">The imprint protocol described here could, however, be used by non-energy constrained devices joining a non-constrained network (for instance, smart light bulbs are usually mains powered, and speak 802.11). It could also be used by non-constrained devices across a non-energy constrained, but challenged network (such as 802.15.4). The certificate contents, and the process by which the four questions above are resolved do apply to constrained devices. It is simply the actual on-the-wire imprint protocol which could be inappropriate.</p>
<p id="rfc.section.1.3.p.8">This document presumes that network access control has either already occurred, is not required, or is integrated by the proxy and registrar in such a way that the device itself does not need to be aware of the details. Although the use of an X.509 Initial Device Identity is consistant with IEEE 802.1AR <a href="#IDevID">[IDevID]</a>, and allows for alignment with 802.1X network access control methods, its use here is for Pledge authentication rather than network access control. Integrating this protocol with network access control, perhaps as an Extensible Authentication Protocol (EAP) method (see <a href="#RFC3748">[RFC3748]</a>), is out-of-scope.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> Architectural Overview</h1>
<p id="rfc.section.2.p.1">The logical elements of the bootstrapping framework are described in this section. Figure 1 provides a simplified overview of the components.  Each component is logical and may be combined with other components as necessary.</p>
<p/>
<pre>                                          .
                                          .+------------------------+
   +--------------Drop Ship--------------&gt;.| Vendor Service         |
   |                                      .+------------------------+
   |                                      .| M anufacturer|         |
   |                                      .| A uthorized  |Ownership|
   |                                      .| S igning     |Tracker  |
   |                                      .| A uthority   |         |
   |                                      .+--------------+---------+
   |                                      ..............  ^
   V                                                      |
+-------+     ............................................|...
|       |     .                                           |  .
|       |     .  +------------+       +-----------+       |  .
|       |     .  |            |       |           |       |  .
|Pledge |     .  |   Circuit  |       | Domain    &lt;-------+  .
|       |     .  |   Proxy    |       | Registrar |          .
|       &lt;--------&gt;            &lt;-------&gt;           |          .
|       |     .  |            |       |           |          .
|X.509  |     .  +------------+       +-----+-----+          .
|IDevID |     .                             |                .
|       |     .           +-----------------+----------+     .
|       |     .           | Key Infrastructure         |     .
|       |     .           | (e.g. PKI Certificate      |     .
+-------+     .           |       Authority)           |     .
              .           +----------------------------+     .
              .                                              .
              ................................................
                            "Domain" components

</pre>
<p>Figure 1</p>
<p id="rfc.section.2.p.3">We assume a multi-vendor network. In such an environment there could be a Vendor Service for each vendor that supports devices following this document's specification, or an integrator could provide a generic service authorized by multiple vendors. It is unlikely that an integrator could provide Ownership Tracking services for multiple vendors due to the required sales channel integrations necessary to track ownership.</p>
<p id="rfc.section.2.p.4">The domain is the managed network infrastructure with a Key Infrastructure the Pledge is joining. The a domain provides initial device connectivity sufficient for bootstrapping with a Circuit Proxy. The Domain registrar authenticates the Pledge, makes authorization decisions, and distributes vouchers obtained from the Vendor Service. Optionally the Registrar also acts as a PKI Registration Authority.</p>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> Secure Imprinting using Vouchers</h1>
<p id="rfc.section.2.1.p.1">A voucher is a cryptographically protected statement to the Pledge device authorizing a zero-touch imprint on the Registrar domain. </p>
<p id="rfc.section.2.1.p.2">The format and cryptographic mechanism of vouchers is described in detail in <a href="#I-D.ietf-anima-voucher">[I-D.ietf-anima-voucher]</a>.</p>
<p id="rfc.section.2.1.p.3">Vouchers provide a flexible mechanism to secure imprinting: the Pledge device only imprints when a voucher can be validated. At the lowest security levels the MASA server can indiscriminately issue vouchers. At the highest security levels issuance of vouchers can be integrated with complex sales channel integrations that are beyond the scope of this document. This provides the flexibility for a number of use cases via a single common protocol mechanism on the Pledge and Registrar devices that are to be widely deployed in the field. The MASA vendor services have the flexibility to leverage either the currently defined claim mechanisms or to experiment with higher or lower security levels.</p>
<p id="rfc.section.2.1.p.4">Vouchers provide a signed but non-encrypted communication channel between the Pledge, the MASA, and the Registrar. The Registrar maintains control over the transport and policy decisions allowing the local security policy of the domain network to be enforced.</p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#IDevIDextension" id="IDevIDextension">Initial Device Identifier</a></h1>
<p id="rfc.section.2.2.p.1">Pledge authentication is via an X.509 certificate installed during the manufacturing process. This Initial Device Identifier provides a basis for authenticating the Pledge during subsequent protocol exchanges and informing the Registrar of the MASA URI. There is no requirement for a common root PKI hierarchy. Each device vendor can generate their own root certificate.</p>
<p id="rfc.section.2.2.p.2">The following previously defined fields are in the X.509 IDevID certificate:</p>
<p/>

<ul>
  <li>The subject field's DN encoding MUST include the "serialNumber" attribute with the device's unique serial number.</li>
  <li>The subject-alt field's encoding SHOULD include a non-critical version of the RFC4108 defined HardwareModuleName.</li>
</ul>
<p id="rfc.section.2.2.p.4">The following newly defined field SHOULD be in the X.509 IDevID certificate: An X.509 non-critical certificate extension that contains a single Uniform Resource Identifier (URI) that points to an on-line Manufacturer Authorized Signing Authority. The URI is represented as described in Section 7.4 of [RFC5280].</p>
<p id="rfc.section.2.2.p.5">Any Internationalized Resource Identifiers (IRIs) MUST be mapped to URIs as specified in Section 3.1 of [RFC3987] before they are placed in the certificate extension. The URI provides the authority information.  The BRSKI .well-known tree is described in <a href="#ProtocolDetails">Section 3</a></p>
<p id="rfc.section.2.2.p.6">The new extension is identified as follows:</p>
<pre>
&lt;CODE BEGINS&gt;

MASAURLExtnModule-2016 { iso(1) identified-organization(3) dod(6)
internet(1) security(5) mechanisms(5) pkix(7)
id-mod(0) id-mod-MASAURLExtn2016(TBD) }

DEFINITIONS IMPLICIT TAGS ::= BEGIN

-- EXPORTS ALL --

IMPORTS
EXTENSION
FROM PKIX-CommonTypes-2009
{ iso(1) identified-organization(3) dod(6) internet(1)
security(5) mechanisms(5) pkix(7) id-mod(0)
id-mod-pkixCommon-02(57) }

id-pe
FROM PKIX1Explicit-2009
{ iso(1) identified-organization(3) dod(6) internet(1)
security(5) mechanisms(5) pkix(7) id-mod(0)
id-mod-pkix1-explicit-02(51) } ;
MASACertExtensions EXTENSION ::= { ext-MASAURL, ... }
ext-MASAURL EXTENSION ::= { SYNTAX MASAURLSyntax
IDENTIFIED BY id-pe-masa-url }

id-pe-masa-url OBJECT IDENTIFIER ::= { id-pe TBD }

MASAURLSyntax ::= IA5String

END

&lt;CODE ENDS&gt;
                  </pre>
<p/>
<p id="rfc.section.2.2.p.8">The choice of id-pe is based on guidance found in Section 4.2.2 of [RFC5280], "These extensions may be used to direct applications to on-line information about the issuer or the subject". The MASA URL is precisely that: online information about the particular subject. </p>
<h1 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a> <a href="#flow" id="flow">Protocol Flow</a></h1>
<p id="rfc.section.2.3.p.1">A representative flow is shown in Figure 2:</p>
<pre>
+--------+         +---------+    +------------+     +------------+
| Pledge |         | Circuit |    | Domain     |     | Vendor     |
|        |         | Proxy   |    | Registrar  |     | Service    |
|        |         |         |    |            |     | (Internet  |
+--------+         +---------+    +------------+     +------------+
  |                     |                   |                    |
  |&lt;-RFC3927 IPv4 adr   | Appendix A        |                    |
or|&lt;-RFC4862 IPv6 adr   |                   |                    |
  |                     |                   |                    |
  |--------------------&gt;|                   |                    |
  | optional: mDNS query| Appendix B        |                    |
  | RFC6763/RFC6762     |                   |                    |
  |                     |                   |                    |
  |&lt;--------------------|                   |                    |
  | GRASP M_FLOOD       |                   |                    |
  |   periodic broadcast|                   |                    |
  |                     |                   |                    |
  |&lt;-------------------&gt;C&lt;-----------------&gt;|                    |
  |              TLS via the Circuit Proxy  |                    |
  |&lt;--Registrar TLS server authentication---|                    |
[PROVISIONAL accept of server cert]         |                    |
  P---X.509 client authentication----------&gt;|                    |
  P                     |                   |                    |
  P---Request Voucher (include nonce)------&gt;|                    |
  P                     |                   |                    |
  P                     |       /---&gt;       |                    |
  P                     |       |      [accept device?]          |
  P                     |       |      [contact Vendor]          |
  P                     |       |           |--Pledge ID--------&gt;|
  P                     |       |           |--Domain ID--------&gt;|
  P                     |       |           |--optional:nonce---&gt;|
  P                     |       |           |     [extract DomainID]
  P                     |       |           |                    |
  P                     |    optional:      |     [update audit log]
  P                     |       |can        |                    |
  P                     |       |occur      |                    |
  P                     |       |in         |                    |
  P                     |       |advance    |                    |
  P                     |       |           |                    |
  P                     |       |           |&lt;-device audit log--|
  P                     |       |           |&lt;- voucher ---------|
  P                     |       \----&gt;      |                    |
  P                     |                   |                    |
  P                     |       [verify audit log and voucher]   |
  P                     |                   |                    |
  P&lt;------voucher---------------------------|                    |
[verify voucher ]       |                   |                    |
[verify provisional cert|                   |                    |
  |                     |                   |                    |
  |&lt;---------------------------------------&gt;|                    |
  | Continue with RFC7030 enrollment        |                    |
  | using now bidirectionally authenticated |                    |
  | TLS session.        |                   |                    |
  |                     |                   |                    |
  |                     |                   |                    |
  |                     |                   |                    |
</pre>
<p>Figure 2</p>
<h1 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4.</a> <a href="#timeunknown" id="timeunknown">Lack of realtime clock</a></h1>
<p id="rfc.section.2.4.p.1">Many devices when bootstrapping do not have knowledge of the current time. Mechanisms like Network Time Protocols can not be secured until bootstrapping is complete. Therefore bootstrapping is defined in a method that does not require knowledge of the current time.</p>
<p id="rfc.section.2.4.p.2">Unfortunately there are moments during bootstrapping when certificates are verified, such as during the TLS handshake, where validity periods are confirmed. This paradoxical "catch-22" is resolved by the Pledge maintaining a concept of the current "window" of presumed time validity that is continually refined throughout the bootstrapping process as follows:</p>
<p/>

<ul>
  <li>Initially the Pledge does not know the current time.</li>
  <li>During Pledge authentiation by the Registrar a realtime clock can be used by the Registrar. This bullet expands on a closely related issue regarding Pledge lifetimes. RFC5280 indicates that long lived Pledge certifiates "SHOULD be assigned the GeneralizedTime value of 99991231235959Z" <a href="#RFC7030">[RFC7030]</a> so the Registrar MUST support such lifetimes and SHOULD support ignoring Pledge lifetimes if they did not follow the RFC5280 recommendations.</li>
  <li>The Pledge authenticates the voucher presented to it. During this authentication the Pledge ignores certificate lifetimes (by necessity because it does not have a realtime clock).</li>
  <li>If the voucher contains a nonce then the Pledge MUST confirm the nonce matches the original voucher request. This ensures the voucher is fresh. See <a href="#RequestVoucherFromRegistrar">/</a> <cite title="NONE">[RequestVoucherFromRegistrar]</cite>.</li>
  <li>Once the voucher is accepted the validity period of the domainCAcert in the voucher (see <a href="#VoucherResponse">Section 3.4</a>) now serves as a valid time window. Any subsequent certificate validity periods checked during RFC5280 path validation MUST occur within this window.</li>
  <li>When accepting an enrollment certificate the validity period within the new certificate is assumed to be valid by the Pledge.  The Pledge is now willing to use this credential for client authentication.</li>
</ul>
<h1 id="rfc.section.2.5"><a href="#rfc.section.2.5">2.5.</a> Cloud Registrar</h1>
<p id="rfc.section.2.5.p.1">The Pledge MAY contact a well known URI of a cloud Registrar if a local Registrar can not be discovered or if the Pledge's target use cases do not include a local Registrar.</p>
<p id="rfc.section.2.5.p.2">If the Pledge uses a well known URI for contacting a cloud Registrar an Implicit Trust Anchor database (see <a href="#RFC7030">[RFC7030]</a>) MUST be used to authenticate service as described in RFC6125. This is consistent with the human user configuration of an EST server URI in <a href="#RFC7030">[RFC7030]</a> which also depends on RFC6125.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#ProtocolDetails" id="ProtocolDetails">Protocol Details</a></h1>
<p id="rfc.section.3.p.1">The Pledge MUST initiate BRSKI after boot if it is unconfigured.  The Pledge MUST NOT automatically initiate BRSKI if it has been configured or is in the process of being configured.</p>
<p id="rfc.section.3.p.2">BRSKI is described as extensions to EST <a href="#RFC7030">[RFC7030]</a> to reduce the number of TLS connections and crypto operations required on the Pledge. The Registrar implements the BRSKI REST interface within the same .well-known URI tree as the existing EST URIs as described in EST <a href="#RFC7030">[RFC7030]</a> section 3.2.2. A MASA URI is therefore "https:// authority "./well-known/est".</p>
<p id="rfc.section.3.p.3">Establishment of the TLS connection for bootstrapping is as specified in EST <a href="#RFC7030">[RFC7030]</a> section 4.1.1 "Bootstrap Distribution of CA Certificates" <a href="#RFC7030">[RFC7030]</a> with the following extensions for automation:</p>
<p id="rfc.section.3.p.4">Automation extensions for the Pledge (equivalent to EST client) are:</p>
<p/>

<ul>
  <li>The Pledge provisionally accepts the Registrar certificate during the TLS handshake as detailed in EST.</li>
  <li>If the Registrar responds with a redirection to other web origins the Pledge MUST follow only a single redirection. (EST supports redirection but does not allow redirections to other web origins without user input).</li>
  <li>The Registar MAY respond with an HTTP 202 ("the request has been accepted for processing, but the processing has not been completed") as described in EST <a href="#RFC7030">[RFC7030]</a> section 4.2.3 wherein the client "MUST wait at least the specified 'retry-after' time before repeating the same request". The Pledge is RECOMMENDED to provide local feed (blinked LED etc) during this wait cycle if mechanisms for this are available. To prevent an attacker Registrar from significantly delaying bootstrapping the Pledge MUST limit the 'retry-after' time to 60 seconds. To avoid waiting on a single erroneous Registrar the Pledge MUST drop the connection after 5 seconds and proceed to other discovered Registrars. Ideally the Pledge could keep track of the appropriate retry-after value for any number of outstanding Registrars but this would involve a large state table on the Pledge. Instead the Pledge MAY ignore the exact retry-after value in favor of a single hard coded value that takes effect between discovery (<a href="#ProxyDiscovery">Appendix D.1.1.1</a>) attempts. A Registrar that is unable to complete the transaction the first time due to timing reasons will have future chances.</li>
  <li>The Pledge requests and validates a voucher using the new REST calls described below.</li>
  <li>If necessary the Pledge calls the EST defined /cacerts method to obtain the current CA certificate. These are validated using the Voucher.</li>
  <li>The Pledge completes authentication of the server certificate as detailed in <a href="#CompletingAuthenticationBootstrapping">Section 3.4.1</a>. This moves the TLS connection out of the provisional state. Optionally the TLS connection can now be used for EST enrollment.</li>
</ul>
<p id="rfc.section.3.p.6">The Pledge establishes the TLS connection with the Registrar through the circuit proxy (see <a href="#proxybehaviour">Appendix D.1.2</a>) but the TLS connection is with the Registar; so in the above section the "Pledge" is the TLS client and the "Registrar" is the TLS server. All security associations established are between the new device and the Registrar regardless of proxy operations.  </p>
<p id="rfc.section.3.p.7">The extensions for a Registrar (equivalent to EST server) are:</p>
<p/>

<ul>
  <li>Client authentication is automated using Initial Device Identity.  The subject field's DN encoding MUST include the "serialNumber" attribute with the device's unique serial number. In the language of RFC6125 this provides for a SERIALNUM-ID category of identifier that can be included in a certificate and therefore that can also be used for matching purposes. The SERIALNUM-ID whitelist is collated according to vendor trust anchor since serial numbers are not globally unique.</li>
  <li>The Registrar requests and validates the Voucher from the vendor authorized MASA service.</li>
  <li>The Registrar forwards the Voucher to the Pledge when requested.</li>
  <li>The Registar performs log verifications in addition to local authorization checks before accepting optional Pledge device enrollment requests.</li>
</ul>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> Discovery</h1>
<p id="rfc.section.3.1.p.1">The result of discovery is a logical communication with a Registrar, through a Proxy. The Proxy is transparent to the Pledge but is always assumed to exist.</p>
<p id="rfc.section.3.1.p.2">To discover the Registrar the Pledge performs the following actions:</p>
<p><a href="#ProtocolDetails">Section 3</a>. </p>

<ol style="list-style-type: lower-alpha">
  <li>MUST: Obtains a local address using IPv6 methods as described in <a href="#RFC4862">[RFC4862]</a> IPv6 Stateless Address AutoConfiguration.  <a href="#RFC7217">[RFC7217]</a> is encouraged.  Pledges will generally prefer use of IPv6 Link-Local addresses, and discovery of Proxy will be by Link-Local mechanisms.  [[EDNOTE: In some environments, a routable public address may be obtained, should it be? Should it be used?]] IPv4 methods are described in <a href="#IPv4operations">Appendix A</a></li>
  <li>MUST: Listen for GRASP M_FLOOD (<a href="#I-D.ietf-anima-grasp">[I-D.ietf-anima-grasp]</a>) announcements of the objective: "ACP+Proxy".  See section <a href="#brskigrasp">Section 3.1.1</a> for the details of the the objective.  The Pledge may listen concurrently for other sources of information, see <a href="#mdnsmethods">Appendix B</a>.  </li>
</ol>

<p> Once a proxy is discovered the Pledge communicates with a Registrar through the proxy using the bootstrapping protocol defined in </p>
<p id="rfc.section.3.1.p.4">Each discovery method attempted SHOULD exponentially back-off attempts (to a maximum of one hour) to avoid overloading the network infrastructure with discovery. The back-off timer for each method MUST be independent of other methods.  </p>
<p id="rfc.section.3.1.p.5">Methods SHOULD be run in parallel to avoid head of queue problems wherein an attacker running a fake proxy or registrar can operate protocol actions intentionally slowly.  </p>
<p id="rfc.section.3.1.p.6">Once a connection to a Registrar is established (e.g. establishment of a TLS session key) there are expectations of more timely responses, see <a href="#RequestVoucherFromRegistrar">Section 3.2</a>.</p>
<p id="rfc.section.3.1.p.7">Once all discovered services are attempted the device SHOULD return to listening for GRASP M_FLOOD.  It should periodically retry the vendor specific mechanisms.  The Pledge MAY prioritize selection order as appropriate for the anticipated environment.</p>
<h1 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#brskigrasp" id="brskigrasp">Proxy Discovery Protocol Details</a></h1>
<pre>
 proxy-objective = ["Proxy", [ O_IPv6_LOCATOR, ipv6-address,
 transport-proto, port-number ] ]

 ipv6-address       - the v6 LL of the proxy
 transport-proto    - 6, for TCP 17 for UDP
 port-number        - the TCP or UDP port number to find the proxy</pre>
<p id="rfc.section.3.1.1.p.1">The proxy uses the GRASP M_FLOOD mechanism to announce itself.  This announcement is done with the same message as the ACP announcement detailed in <a href="#I-D.ietf-anima-autonomic-control-plane">[I-D.ietf-anima-autonomic-control-plane]</a>.  </p>

<p>Figure 5</p>
<h1 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#discovery" id="discovery">Registrar Discovery Protocol Details</a></h1>
<p id="rfc.section.3.1.2.p.1">A Registrar is typically configured manually.  When the Registrar joins an Autonomic Control Plane (<a href="#I-D.ietf-anima-autonomic-control-plane">[I-D.ietf-anima-autonomic-control-plane]</a>) it MUST respond to GRASP (<a href="#I-D.ietf-anima-grasp">[I-D.ietf-anima-grasp]</a>) M_NEG_SYN message.  </p>
<pre>
 objective         = ["AN_registrar", F_DISC, 255 ]
 discovery-message = [M_NEG_SYN, session-id, initiator, objective]</pre>
<p id="rfc.section.3.1.2.p.2">The registrar responds to discovery messages from the proxy (or GRASP caches between them) as follows: (XXX changed from M_DISCOVERY) </p>

<p>Figure 6: Registrar Discovery</p>
<pre>
 response-message = [M_RESPONSE, session-id, initiator, ttl,
 (+locator-option // divert-option), ?objective)]
 initiator = ACP address of Registrar
 locator1  = [O_IPv6_LOCATOR, fd45:1345::6789, 6,  443]
 locator2  = [O_IPv6_LOCATOR, fd45:1345::6789, 17, 5683]
 locator3  = [O_IPv6_LOCATOR, fe80::1234, 41, nil]</pre>
<p id="rfc.section.3.1.2.p.3">The response from the registrar (or cache) will be a M_RESPONSE with the following parameters:</p>

<p>Figure 7: Registrar Response</p>
<p id="rfc.section.3.1.2.p.4">The set of locators is to be interpreted as follows.  A protocol of 6 indicates that TCP proxying on the indicated port is desired.  A protocol of 17 indicates that UDP proxying on the indicated port is desired.  In each case, the traffic SHOULD be proxied to the same port at the ULA address provided.  </p>
<p id="rfc.section.3.1.2.p.5">A protocol of 41 indicates that packets may be IPIP proxy'ed.  In the case of that IPIP proxying is used, then the provided link-local address MUST be advertised on the local link using proxy neighbour discovery.  The Join Proxy MAY limit forwarded traffic to the protocol (6 and 17) and port numbers indicated by locator1 and locator2.  The address to which the IPIP traffic should be sent is the initiator address (an ACP address of the Registrar), not the address given in the locator.  </p>
<p id="rfc.section.3.1.2.p.6">Registrars MUST accept TCP / UDP traffic on the ports given at the ACP address of the Registrar.  If the Registrar supports IPIP tunnelling, it MUST also accept traffic encapsulated with IPIP.  </p>
<p id="rfc.section.3.1.2.p.7">Registrars MUST accept HTTPS/EST traffic on the TCP ports indicated.  Registrars MAY accept DTLS/CoAP/EST traffic on the UDP in addition to TCP traffic.  </p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#RequestVoucherFromRegistrar" id="RequestVoucherFromRegistrar">Request Voucher from the Registrar</a></h1>
<p id="rfc.section.3.2.p.1">When the Pledge bootstraps it makes a request for a Voucher from a Registrar.</p>
<p id="rfc.section.3.2.p.2">This is done with an HTTPS POST using the operation path value of "/requestvoucher".</p>
<p id="rfc.section.3.2.p.3">The request media types are:</p>
<p/>

<dl>
  <dt>application/voucherrequest</dt>
  <dd style="margin-left: 8">The request is a "YANG-defined JSON document that has been signed using a PKCS#7 structure" as described in <a href="#I-D.ietf-anima-voucher">[I-D.ietf-anima-voucher]</a> using the JSON encoded described in <a href="#RFC7951">[RFC7951]</a>. Signing the request is RECOMMENDED if the Pledge has sufficient processing to perform the crypto operations. Doing so allows the Registrar to forward the Pledge's signed 'proximity' assertion to the MASA as discussed in the security considerations.</dd>
  <dt>application/unsignedvoucherrequest</dt>
  <dd style="margin-left: 8">The request is the "YANG-defined JSON document" but has not been signed. It is the inner JSON structure protected only by the TLS client authentication.  This reduces the cryptographic requirements on the Pledge.</dd>
</dl>
<p id="rfc.section.3.2.p.5">For simplicity the term 'voucher request' is used to refer to either of these media types. Registrar impementations SHOULD anticipate future media types but of course will simply fail the request if those types are not yet known.</p>
<p id="rfc.section.3.2.p.6">The Pledge populates the voucher request fields as follows:</p>
<p/>

<dl>
  <dt>created-on:</dt>
  <dd style="margin-left: 8">Pledges that have a realtime clock are RECOMMENDED to populate this field. This provides additional information to the MASA.</dd>
  <dt>nonce:</dt>
  <dd style="margin-left: 8">The voucher request MUST contain a cryptographically strong random or pseudo-random number nonce. Doing so ensures <a href="#timeunknown">Section 2.4</a> functionality. The nonce MUST NOT be reused for multiple bootstrapping attempts.</dd>
  <dt>assertion:</dt>
  <dd style="margin-left: 8">The voucher request MAY contain an assertion of "proximity".</dd>
  <dt>pinned-domain-cert:</dt>
  <dd style="margin-left: 8">In a Pledge voucher request this is the Registrar certificate as extracted from the TLS handshake (for example the first certificate in the TLS 'certificate_list' sequence (see <a href="#RFC5246">[RFC5246]</a>). This MUST be populated in a Pledge's voucher request if the "proximity" assertion is populated.</dd>
</dl>
<p id="rfc.section.3.2.p.8">All other fields MAY be ommitted in the voucher request.</p>
<p id="rfc.section.3.2.p.9">An example JSON payload of a voucher request from a Pledge:</p>
<pre>
{
  "ietf-voucher:voucher": {
    "nonce": "62a2e7693d82fcda2624de58fb6722e5",
    "created-on": "2017-01-01T00:00:00.000Z",
    "assertion": "proximity",
    "pinned-domain-cert": "&lt;base64 encoded certificate&gt;"
  }
}
</pre>
<p/>
<p id="rfc.section.3.2.p.11">The Registrar validates the client identity as described in EST <a href="#RFC7030">[RFC7030]</a> section 3.3.2. If the request is signed the Registrar confirms the 'proximity' asserion and associated 'pinned-domain-cert' are correct. The registrar performs authorization as detailed in [[EDNOTE: UNRESOLVED. See Appendix D "Pledge Authorization"]]. If these validations fail the Registrar SHOULD respond with an appropriate HTTP error code.</p>
<p id="rfc.section.3.2.p.12">If authorization is successful the Registrar obtains a voucher from the MASA service (see <a href="#RequestVoucherFromMASA">Section 3.3</a>) and returns that MASA signed voucher to the pledge as described in <a href="#VoucherResponse">Section 3.4</a>.</p>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#RequestVoucherFromMASA" id="RequestVoucherFromMASA">Request Voucher from MASA</a></h1>
<p id="rfc.section.3.3.p.1">when a Registrar recieves a voucher request from a Pledge it in turn requests a voucher from the MASA service. For simplicity this is defined as an optional EST message between a Registrar and an EST server running on the MASA service although the Registrar is not required to make use of any other EST functionality when communicating with the MASA service. (The MASA service MUST properly reject any EST functionality requests it does not wish to service; a requirement that holds for any REST interface).</p>
<p id="rfc.section.3.3.p.2">This is done with an HTTP POST using the operation path value of "/requestvoucher".</p>
<p id="rfc.section.3.3.p.3">The request media type is:</p>
<p/>

<dl>
  <dt>application/voucherrequest</dt>
  <dd style="margin-left: 8">The request is a "YANG-defined JSON document that has been signed using a PKCS#7 structure" as described in <a href="#I-D.ietf-anima-voucher">[I-D.ietf-anima-voucher]</a> using the JSON encoded described in <a href="#RFC7951">[RFC7951]</a>. The Registrar MUST sign the request. The entire Registrar certificate chain, up to and including the Domain CA, MUST be included in the PKCS#7 structure.</dd>
</dl>
<p id="rfc.section.3.3.p.5">For simplicity the term 'voucher request' is used.  MASA impementations SHOULD anticipate future media types but of course will simply fail the request if those types are not yet known.</p>
<p id="rfc.section.3.3.p.6">The Registrar populates the voucher request fields as follows:</p>
<p/>

<dl>
  <dt>created-on:</dt>
  <dd style="margin-left: 8">Registrars are RECOMMENDED to populate this field. This provides additional information to the MASA.</dd>
  <dt>nonce:</dt>
  <dd style="margin-left: 8">The optional nonce value from the Pledge request if desired (see below).</dd>
  <dt>serial-number:</dt>
  <dd style="margin-left: 8">The serial number of the Pledge the Registrar would like a voucher for.</dd>
  <dt>idevid-issuer:</dt>
  <dd style="margin-left: 8">The idevid-issuer value from the pledge certificate is included to ensure a statistically unique identity. The Pledge's serial number is extracted from the X.509 IDevID. See <a href="#IDevIDextension">Section 2.2</a>.</dd>
  <dt>prior-signed-voucher:</dt>
  <dd style="margin-left: 8">If the Pledge provided a signed voucher request then it SHOULD be included in the voucher request built by the Registrar.</dd>
</dl>
<p id="rfc.section.3.3.p.8">All other fields MAY be ommitted in the voucher request.</p>
<p id="rfc.section.3.3.p.9">An example JSON payload of a voucher request from a Registrar:</p>
<pre>
{
  "ietf-voucher:voucher": {
    "nonce": "62a2e7693d82fcda2624de58fb6722e5",
    "created-on": "2017-01-01T00:00:00.000Z",
    "assertion": "proximity"
    "idevid-issuer": "&lt;base64 encoded Authority Key Identifier&gt;"
    "serial-number": "JADA123456789"
    "prior-signed-voucher": "&lt;base64 encode prior voucher request&gt;"
  }
}
</pre>
<p/>
<p id="rfc.section.3.3.p.11">A Registrar MAY exclude the nonce from the voucher request it submits to the MASA. Doing so allows the Registrar to request a Voucher when the Pledge is offline, or when the Registrar is expected to be offline when the Pledge is being deployed. These use cases require the Registrar to learn the appropriate DevIDSerialNumber field from the physical device labeling or from the sales channel (out-of-scope of this document). If a nonce is not provided the MASA server MUST authenticate the Registrar as described in EST <a href="#RFC7030">[RFC7030]</a> section 3.3.2 to reduce the risk of DDoS attacks and to provide an authenticated identity as an input to sales channel integration and authorizations (also out-of-scope of this document).</p>
<p id="rfc.section.3.3.p.12">As described in <a href="#I-D.ietf-anima-voucher">[I-D.ietf-anima-voucher]</a> vouchers are normally short lived to avoid revocation issues. If the request is for a previous (expired) voucher using the same Registrar (as determined by Registrar's' domainID) and the MASA has not been informed that the claim is invalid - the request for a renewed voucher SHOULD be automatically authorized. If authorization is successful the MASA responds with a <a href="#I-D.ietf-anima-voucher">[I-D.ietf-anima-voucher]</a> voucher. The MASA SHOULD check for revocation of the Registrar certificate. The maximum lifetime of the voucher issued SHOULD NOT exceed the lifetime of the Registrar's revocation validation (for example if the Registrar revocation status is indicated in a CRL that is valid for two weeks then that is an appropriate lifetime for the voucher).</p>
<p id="rfc.section.3.3.p.13">TThe MASA service checks the internal consistency of the voucher request but does not authenticate the domain identity information since the domain is not know to the MASA server in advance. The MASA server MUST verify that the voucher request is signed by a Registrar certificate (by checking for the cmc-idRA field) that was issued by the self signed root certificate included in the request.  [[ EDNOTE: can we simplify the above sentence? ]] This ensures that the Registrar making the claim is an authorized Registrar of the unauthenticated domain.  The MASA server MAY verify that the Registrar's signed voucher includes the 'prior-signed-voucher' field populated with a voucher, signed by the Pledge, that includes a pinned-domain-cert that is consistent with the Registrar certificate chain. The MASA server is aware of which Pledge's support signing of their voucher requests and can use this information to confirm proximity of the Pledge with the Registrar.</p>
<p id="rfc.section.3.3.p.14">The root certificate is extracted and used to populate the Voucher being issued. The domain ID (e.g. hash of the public key of the domain) is extracted from the root certificate and is used to update the audit log.</p>
<h1 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#VoucherResponse" id="VoucherResponse">Voucher Response</a></h1>
<p id="rfc.section.3.4.p.1">The voucher response to requests from the Pledge and requests from a Registrar are in the same format. A Registrar either caches prior MASA responses or dynamically requests a new Voucher based on local policy.</p>
<p id="rfc.section.3.4.p.2">If the the join operation is successful, the server response MUST contain an HTTP 200 response code. The server MUST answer with a suitable 4xx or 5xx HTTP [RFC2616] error code when a problem occurs.  The response data from the MASA server MUST be a plaintext human-readable (ASCII, english) error message containing explanatory information describing why the request was rejected.</p>
<p id="rfc.section.3.4.p.3">Response media type: application/voucher+cms</p>
<p id="rfc.section.3.4.p.4">The syntactic details of vouchers are described in detail in <a href="#I-D.ietf-anima-voucher">[I-D.ietf-anima-voucher]</a>. For example, the voucher consists of:</p>
<pre>
{
  "ietf-voucher:voucher": {
    "nonce": "62a2e7693d82fcda2624de58fb6722e5",
    "assertion": "logging"
    "pinned-domain-cert": "&lt;base64 encoded certificate&gt;"
    "serial-number": "JADA123456789"
  }
}
</pre>
<p id="rfc.section.3.4.p.5">The Pledge verifies the signed voucher using the manufacturer installed trust anchor associated with the vendor's selected Manufacturer Authorized Signing Authority.</p>
<p id="rfc.section.3.4.p.6">The 'pinned-domain-cert' element of the voucher contains the domain CA's public key. The Pledge MUST use the 'pinned-domain-cert' trust anchor to immediately complete authentication of the provisional TLS connection.</p>
<p id="rfc.section.3.4.p.7">The Pledge MUST be prepared to parse and fail gracefully from an Voucher response that does not contain a 'pinned-domain-cert' field. The Pledge MUST be prepared to ignore additional fields it does not recognize.  </p>
<h1 id="rfc.section.3.4.1"><a href="#rfc.section.3.4.1">3.4.1.</a> <a href="#CompletingAuthenticationBootstrapping" id="CompletingAuthenticationBootstrapping">Completing authentication of Provisional TLS connection</a></h1>
<p id="rfc.section.3.4.1.p.1">If a Registrar's credentials can not be verified using the pinned-domain-cert trust anchor from the voucher then the TLS connection is immediately discarded and the Pledge abandons attempts to bootstrap with this discovered registrar. The pledge SHOULD send voucher status telemetry (described below) before closing the TLS connection.  The pledge MUST attempt to enroll using any other proxies it has found.  It SHOULD return to the same proxy again after attempting with other proxies.  Attempts should be attempted in the exponential backoff described earlier.  Attempts SHOULD be repeated as failure may be the result of a temporary inconsistently (an inconsistently rolled Registrar key, or some other mis-configuration).  The inconsistently could also be the result an active MITM attack on the EST connection.  </p>
<p id="rfc.section.3.4.1.p.2">The Registrar MUST use a certificate that chains to the pinned-domain-cert as its TLS server certificate.  </p>
<p id="rfc.section.3.4.1.p.3">The Pledge's PKIX path validation of a Registrar certificate's validity period information is as described in <a href="#timeunknown">Section 2.4</a>.  Once the PKIX path validation is successful the TLS connection is no longer provisional.</p>
<p id="rfc.section.3.4.1.p.4">The pinned-domain-cert is installed as an Explicit Trust Anchor for future operations. It can therefore can be used to authenticate any dynamically discovered EST server that contain the id-kp-cmcRA extended key usage extension as detailed in EST RFC7030 section 3.6.1; but to reduce system complexity the Pledge SHOULD avoid additional discovery operations. Instead the Pledge SHOULD communicate directly with the Registrar as the EST server. The ' pinned-domain-cert' is not a complete distribution of the EST section 4.1.3 CA Certificate Response which is an additional justification for the recommendation to proceed with EST key management operations. Once a full CA Certificate Response is obtained it is more authoritative for the domain than the limited 'pinned-domain-cert' response.'</p>
<h1 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> Voucher Status Telemetry </h1>
<p id="rfc.section.3.5.p.1">The domain is expected to provide indications to the system administrators concerning device lifecycle status. To facilitate this it needs telemetry information concerning the device's status.</p>
<p id="rfc.section.3.5.p.2">To indicate Pledge status regarding the Voucher the client SHOULD post a status message.</p>
<p id="rfc.section.3.5.p.3">The posted data media type: application/json</p>
<p id="rfc.section.3.5.p.4">The client HTTP POSTs the following to the server at the EST well known URI /voucher_status. The Status field indicates if the Voucher was acceptable. If it was not acceptable the Reason string indicates why. In the failure case this message is being sent to an unauthenticated, potentially malicious Registrar and therefore the Reason string SHOULD NOT provide information beneficial to an attacker. The operational benefit of this telemetry information is balanced against the operational costs of not recording that an Voucher was ignored by a client the registar expected to continue joining the domain.</p>
<p id="rfc.section.3.5.p.5">[[EDNOTE: the server can know which pledge failed by the previous voucher, I think. Is this worth noting?]] </p>
<pre>{
  "version":"1",
  "Status":FALSE /* TRUE=Success, FALSE=Fail"
  "Reason":"Informative human readable message"
}</pre>
<p/>
<h1 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6.</a> MASA authorization log Request </h1>
<p id="rfc.section.3.6.p.1">A registrar requests the MASA authorization log from the MASA service using this EST extension. If a device had previously registered with another domain, a Registrar of that domain would show in the log.</p>
<p id="rfc.section.3.6.p.2">This is done with an HTTP GET using the operation path value of "/requestauditlog".</p>
<p id="rfc.section.3.6.p.3">The client MUST HTTP POSTs the same Voucher Request as for requesting a Voucher. It is posted to the /requestauditlog URI instead. The IDevIDAuthorityKeyIdentifier and DevIDSerialNumber informs the MASA server which log is requested so the appropriate log can be prepared for the response. Using the same media type and message minimizes cryptographic and message operations although it results in additional network traffic. The relying MASA server implementation MAY leverage internal state to associate this request with the original, and by now already validated, voucher request so as to avoid an extra crypto validation.</p>
<p id="rfc.section.3.6.p.4">Request media type: application/voucherrequest+cms</p>
<h1 id="rfc.section.3.7"><a href="#rfc.section.3.7">3.7.</a> MASA authorization log Response</h1>
<p id="rfc.section.3.7.p.1">A log data file is returned consisting of all log entries. For example:</p>
<pre>{
  "version":"1",
  "events":[
    {
     "date":"&lt;date/time of the entry&gt;",
     "domainID":"&lt;domainID as extracted from the domain CA certificate
                  within the CMS of the audit voucher request&gt;",
     "nonce":"&lt;any nonce if supplied (or the exact string 'NULL')&gt;"
    },
    {
     "date":"&lt;date/time of the entry&gt;",
     "domainID":"&lt;domainID as extracted from the domain CA certificate
                  within the CMS of the audit voucher request&gt;",
     "nonce":"&lt;any nonce if supplied (or the exact string 'NULL')&gt;"
    }
  ]
}</pre>
<p/>
<p id="rfc.section.3.7.p.3">Distribution of a large log is less than ideal. This structure can be optimized as follows: All nonce-less entries for the same domainID MAY be condensed into the single most recent nonceless entry.</p>
<p id="rfc.section.3.7.p.4">A Registrar SHOULD use this log information to make an informed decision regarding the continued bootstrapping of the Pledge. For example if the log includes unexpected domainIDs this is indicative of problematic imprints by the Pledge. If the log includes nonce-less entries this is indicative of the permanent ability for the indicated domain to trigger a reset of the device and take over management of it. Equipment that is purchased pre-owned can be expected to have an extensive history. A Registrar MAY request logs at future times [[EDNOTE: we need to ensure MASA server is not slammed with too many requests]].  A Registrar MAY be configured to ignore the history of the device but it is RECOMMENDED that this only be configured if hardware assisted NEA [RFC5209] is supported.</p>
<p id="rfc.section.3.7.p.5">Log entries containing the Domain's ID can be compared against local history logs in search of discrepancies.</p>
<p id="rfc.section.3.7.p.6">This document specifies a simple log format as provided by the MASA service to the registar. This format could be improved by distributed consensus technologies that integrate vouchers with a technologies such as block-chain or hash trees or the like. Doing so is out of the scope of this document but are anticipated improvements for future work.  As such, the Registrar client SHOULD anticipate new kinds of responses, and SHOULD provide operator controls to indicate how to process unknown responses.  </p>
<h1 id="rfc.section.3.8"><a href="#rfc.section.3.8">3.8.</a> EST Integration for PKI bootstrapping</h1>
<p id="rfc.section.3.8.p.1">This section describes EST extensions necessary to enable fully automated bootstrapping. Although the Voucher request/response structure members IDevIDAuthorityKeyIdentifier and DevIDSerialNumber are specific to PKI bootstrapping these are the only PKI specific aspects of the extensions and future work might replace them with non-PKI structures.</p>
<p id="rfc.section.3.8.p.2">Once the Voucher is received, as specified in this document, the client has sufficient information to leverage the existing communication channel with a Registrar to continue an EST RFC7030 enrollment. The Pledge SHOULD use the existing current TLS connection to proceed with EST enrollment, thus reducing the total amount of cryptographic and round trip operations required during bootstrapping (enrollment picks up after EST RFC7030 "Bootstrap Distribution of CA Certificates" and the client continues with EST enrollment operations including "CA Certificates Request", "CSR Attributes" and "Client Certificate Request" or "Server-Side Key Generation").</p>
<p id="rfc.section.3.8.p.3">The Pledge is RECOMMENDED to implement the following EST automation extensions. They supplement the RFC7030 EST to better support automated devices that do not have an end user.</p>
<p id="rfc.section.3.8.p.4">[[EDNOTE:might be best to discuss in CSR attributes?]]For the purposes of creating the ANIMA Autonomic Control Plane, the contents of the new certificate MUST be carefully specified.  <a href="#I-D.ietf-anima-autonomic-control-plane">[I-D.ietf-anima-autonomic-control-plane]</a> section 5.1.1 contains details.  The Registrar MUST provide the the correct ACP information to populate the subjectAltName / rfc822Name field in the "CSR Attributes" step.  </p>
<h1 id="rfc.section.3.8.1"><a href="#rfc.section.3.8.1">3.8.1.</a> EST Distribution of CA Certificates</h1>
<p id="rfc.section.3.8.1.p.1">The Pledge MUST request the full EST Distribution of CA Certificates message. See RFC7030, section 4.1.</p>
<p id="rfc.section.3.8.1.p.2">This ensures that the Pledge has the complete set of current CA certificates beyond the domainCAcert (see <a href="#VoucherResponse">Section 3.4</a> for a discussion of the limitations). Although these restrictions are acceptable for a Registrar integrated with initial bootstrapping they are not appropriate for ongoing PKIX end entity certificate validation.</p>
<h1 id="rfc.section.3.8.2"><a href="#rfc.section.3.8.2">3.8.2.</a> EST CSR Attributes</h1>
<p id="rfc.section.3.8.2.p.1">Automated bootstrapping occurs without local administrative configuration of the Pledge. In some deployments its plausible that the Pledge generates a certificate request containing only identity information known to the Pledge (essentially the X.509 IDevID information) and ultimately receives a certificate containing domain specific identity information. Conceptually the CA has complete control over all fields issued in the end entity certificate. Realistically this is operationally difficult with the current status of PKI certificate authority deployments where the CSR is submitted to the CA via a number of non-standard protocols.</p>
<p id="rfc.section.3.8.2.p.2">To alleviate operational difficulty the Pledge MUST request the EST "CSR Attributes" from the EST server. This allows the local infrastructure to inform the Pledge of the proper fields to include in the generated CSR.</p>
<p id="rfc.section.3.8.2.p.3">[[EDNOTE: The following is specific to anima purposes and should be moved to an appropriate anima document so as to keep bootstrapping as generic as possible: What we want are a 'domain name' stored in [TBD] and an 'ACP IPv6 address' stored in the iPAddress field as specified in RFC5208 s4.2.1.6. ref ACP draft where certificate verification [TBD]. These should go into the subjectaltname in the [TBD] fields.]]. If the hardwareModuleName in the X.509 IDevID is populated then it SHOULD by default be propagated to the LDevID along with the hwSerialNum. The registar SHOULD support local policy concerning this functionality. [[EDNOTE: extensive use of EST CSR Attributes might need an new OID definition]].]]</p>
<p id="rfc.section.3.8.2.p.4">The Registar MUST also confirm the resulting CSR is formatted as indicated before forwarding the request to a CA. If the Registar is communicating with the CA using a protocol like full CMC which provides mechanisms to override the CSR attributes, then these mechanisms MAY be used even if the client ignores CSR Attribute guidance.</p>
<h1 id="rfc.section.3.8.3"><a href="#rfc.section.3.8.3">3.8.3.</a> EST Client Certificate Request</h1>
<p id="rfc.section.3.8.3.p.1">The Pledge MUST request a new client certificate. See RFC7030, section 4.2.</p>
<h1 id="rfc.section.3.8.4"><a href="#rfc.section.3.8.4">3.8.4.</a> Enrollment Status Telemetry</h1>
<p id="rfc.section.3.8.4.p.1">For automated bootstrapping of devices the adminstrative elements providing bootstrapping also provide indications to the system administrators concerning device lifecycle status. This might include information concerning attempted bootstrapping messages seen by the client, MASA provides logs and status of credential enrollment. The EST protocol assumes an end user and therefore does not include a final success indication back to the server. This is insufficient for automated use cases.</p>
<p id="rfc.section.3.8.4.p.2">To indicate successful enrollment the client SHOULD re-negotiate the EST TLS session using the newly obtained credentials. This occurs by the client initiating a new TLS ClientHello message on the existing TLS connection. The client MAY simply close the old TLS session and start a new one. The server MUST support either model.</p>
<p id="rfc.section.3.8.4.p.3">In the case of a FAIL the Reason string indicates why the most recent enrollment failed. The SubjectKeyIdentifier field MUST be included if the enrollment attempt was for a keypair that is locally known to the client. If EST /serverkeygen was used and failed then the field is omitted from the status telemetry.</p>
<p id="rfc.section.3.8.4.p.4">In the case of a SUCCESS the Reason string is omitted. The SubjectKeyIdentifier is included so that the server can record the successful certificate distribution.</p>
<p id="rfc.section.3.8.4.p.5">Status media type: application/json</p>
<p id="rfc.section.3.8.4.p.6">The client HTTP POSTs the following to the server at the new EST well known URI /enrollstatus.</p>
<pre>{
  "version":"1",
  "Status":TRUE /* TRUE=Success, FALSE=Fail"
  "Reason":"Informative human readable message"
  "SubjectKeyIdentifier":"&lt;base64 encoded subjectkeyidentifier for the
                           enrollment that failed&gt;"
}</pre>
<p/>
<p id="rfc.section.3.8.4.p.8">The server SHOULD respond with an HTTP 200 but MAY simply fail with an HTTP 404 error.</p>
<p id="rfc.section.3.8.4.p.9">Within the server logs the server MUST capture if this message was received over an TLS session with a matching client certificate.  This allows for clients that wish to minimize their crypto operations to simply POST this response without renegotiating the TLS session - at the cost of the server not being able to accurately verify that enrollment was truly successful.</p>
<h1 id="rfc.section.3.8.5"><a href="#rfc.section.3.8.5">3.8.5.</a> EST over CoAP</h1>
<p id="rfc.section.3.8.5.p.1">[[EDNOTE: In order to support smaller devices the above section on Proxy behavior introduces mandatory to implement support for CoAP support by the Proxy. This implies similar support by the Pledge and Registrar and means that the EST protocol operation encapsulation into CoAP needs to be described. EST is HTTP based and "CoaP is designed to easily interface with HTTP for integration" [RFC7252].  Use of CoAP implies Datagram TLS (DTLS) wherever this document describes TLS handshake specifics. A complexity is that the large message sizes necessary for bootstrapping will require support for [draft-ietf-core-block].]]</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#reducedsecuritymodes" id="reducedsecuritymodes">Reduced security operational modes</a></h1>
<p id="rfc.section.4.p.1">A common requirement of bootstrapping is to support less secure operational modes for support specific use cases. The following sections detail specific ways that the Pledge, Registrar and MASA can be configured to run in a less secure mode for the indicated reasons.</p>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> Trust Model</h1>
<pre>
+--------+         +---------+    +------------+     +------------+
| Pledge |         | Circuit |    | Domain     |     | Vendor     |
|        |         | Proxy   |    | Registrar  |     | Service    |
|        |         |         |    |            |     | (Internet  |
+--------+         +---------+    +------------+     +------------+
              </pre>
<p>Figure 10</p>
<p/>

<dl>
  <dt>Pledge:</dt>
  <dd style="margin-left: 8">The Pledge could be compromised and providing an attack vector for malware. The entity is trusted to only imprint using secure methods described in this document.  Additional endpoint assessment techniques are RECOMMENDED but are out-of-scope of this document.</dd>
  <dt>Proxy:</dt>
  <dd style="margin-left: 8">Provides proxy functionalities but is not involved in security considerations.</dd>
  <dt>Registrar:</dt>
  <dd style="margin-left: 8">When interacting with a MASA server a Registrar makes all decisions. When Ownership Vouchers are involved a Registrar is only a conduit and all security decisions are made on the vendor service.</dd>
  <dt>Vendor Service, MASA:</dt>
  <dd style="margin-left: 8">This form of vendor service is trusted to accurately log all claim attempts and to provide authoritative log information to Registrars. The MASA does not know which devices are associated with which domains. These claims could be strengthened by using cryptographic log techniques to provide append only, cryptographic assured, publicly auditable logs. Current text provides only for a trusted vendor.</dd>
  <dt>Vendor Service, Ownership Validation:</dt>
  <dd style="margin-left: 8">This form of vendor service is trusted to accurately know which device is owned by which domain.</dd>
</dl>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> Pledge security reductions</h1>
<p id="rfc.section.4.2.p.1">The Pledge can choose to accept vouchers using less secure methods. These methods enable offline and emergency (touch based) deployment use cases: </p>

<ol>
  <li>The Pledge MUST accept nonceless vouchers. This allows for offline use cases. Logging and validity periods address the inherent security considerations of supporting these use cases.</li>
  <li>The Pledge MAY support "trust on first use" for physical interfaces such as a local console port or physical user interface but MUST NOT support "trust on first use" on network interfaces. This is because "trust on first use" permanently degrades the security for all use cases.</li>
  <li>The Pledge MAY have an operational mode where it skips Voucher validation one time. For example if a physical button is depressed during the bootstrapping operation. This can be useful if the vendor service is unavailable. This behavior SHOULD be available via local configuration or physical presence methods to ensure new entities can always be deployed even when autonomic methods fail. This allows for unsecured imprint.</li>
</ol>
<p id="rfc.section.4.2.p.2">It is RECOMMENDED that "trust on first use" or skipping voucher validation only be available if hardware assisted Network Endpoint Assessment [RFC5209] is supported. This recommendation ensures that domain network monitoring can detect innappropriate use of offline or emergency deployment procedures.</p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> Registrar security reductions</h1>
<p id="rfc.section.4.3.p.1">A Registrar can choose to accept devices using less secure methods.  These methods are acceptable when low security models are needed, as the security decisions are being made by the local administrator, but they MUST NOT be the default behavior:</p>

<ol>
  <li>A registrar MAY choose to accept all devices, or all devices of a particular type, at the administrator's discretion. This could occur when informing all Registrars of unique identifiers of new entities might be operationally difficult.</li>
  <li>A registrar MAY choose to accept devices that claim a unique identity without the benefit of authenticating that claimed identity. This could occur when the Pledge does not include an X.509 IDevID factory installed credential. New Entities without an X.509 IDevID credential MAY form the <a href="#RequestVoucherFromRegistrar">Section 3.2</a> request using the <a href="#RequestVoucherFromMASA">Section 3.3</a> format to ensure the Pledge's serial number information is provided to the Registar (this includes the IDevIDAuthorityKeyIdentifier value which would be statically configured on the Pledge). The Pledge MAY refuse to provide a TLS client certificate (as one is not available). The Pledge SHOULD support HTTP-based or certificate-less TLS authentication as described in EST RFC7030 section 3.3.2. A Registrar MUST NOT accept unauthenticated New Entities unless it has been configured to do so by an administrator that has verified that only expected new entities can communicate with a Registrar (presumably via a physically secured perimeter).</li>
  <li>A Registrar MAY request nonce-less Vouchers from the MASA service (by not including a nonce in the request). These Vouchers can then be transmitted to the Registrar and stored until they are needed during bootstrapping operations. This is for use cases where target network is protected by an air gap and therefore can not contact the MASA service during Pledge deployment.</li>
  <li>A registrar MAY ignore unrecognized nonce-less log entries. This could occur when used equipment is purchased with a valid history being deployed in air gap networks that required permanent Vouchers.</li>
</ol>
<h1 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> MASA security reductions</h1>
<p id="rfc.section.4.4.p.1">Lower security modes chosen by the MASA service effect all device deployments unless bound to the specific device identities. In which case these modes can be provided as additional features for specific customers. The MASA service can choose to run in less secure modes by:</p>
<p/>

<ol>
  <li>Not enforcing that a nonce is in the Voucher. This results in distribution of Voucher that never expires and in effect makes the Domain an always trusted entity to the Pledge during any subsequent bootstrapping attempts. That this occurred is captured in the log information so that the Domain registrar can make appropriate security decisions when a Pledge joins the Domain. This is useful to support use cases where Registrars might not be online during actual device deployment. Because this results in long lived Voucher and does not require the proof that the device is online this is only accepted when the Registrar is authenticated by the MASA server and authorized to provide this functionality. The MASA server is RECOMMENDED to use this functionality only in concert with an enhanced level of ownership tracking (out-of-scope). If the Pledge device is known to have a real-time-clock that is set from the factory use of a voucher validity period is RECOMMENDED.</li>
  <li>Not verifying ownership before responding with an Voucher. This is expected to be a common operational model because doing so relieves the vendor providing MASA services from having to track ownership during shipping and supply chain and allows for a very low overhead MASA service. A Registrar uses the audit log information as a defense in depth strategy to ensure that this does not occur unexpectedly (for example when purchasing new equipment the Registrar would throw an error if any audit log information is reported). The MASA should verify the 'prior-signed-voucher' information for Pledge's that support that functionality. This provides a proof-of-proximity check that reduces the need for ownership verification.</li>
</ol>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> IANA Considerations</h1>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> PKIX Registry</h1>
<p id="rfc.section.5.1.p.1">This document requests a number for id-mod-MASAURLExtn2016(TBD) from the pkix(7) id-mod(0) Registry. [[EDNOTE: fix names]] </p>
<p id="rfc.section.5.1.p.2">This document requests a number from the id-pe registry for id-pe-masa-url. XXX </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> Security Considerations</h1>
<p id="rfc.section.6.p.1">There are uses cases where the MASA could be unavailable or uncooperative to the Registrar. They include planned and unplanned network partitions, changes to MASA policy, or other instances where MASA policy rejects a claim. These introduce an operational risk to the Registrar owner that MASA/vendor behavior might limit the ability to re-boostrap a Pledge device. For example this might be an issue during disaster recovery. This risk can be mitigated by Registrars that request and maintain long term copies of "nonceless" Vouchers. In that way they are guaranteed to be able to repeat bootstrapping for their devices.</p>
<p id="rfc.section.6.p.2">The issuance of nonceless vouchers themselves create a security concern. If the Registrar of a previous domain can intercept protocol communications then it can use a previously issued nonceless voucher to establish management control of a pledge device even after having sold it. This risk is mitigated by recording the issuance of such vouchers in the MASA audit log that is verified by the subsequent Registrar.  This reduces the resale value of the equipment because future owners will detect the lowered security inherent in the existence of a nonceless voucher that would be trusted by their Pledge. This reflects a balance between partition resistant recovery and security of future bootstrapping. Registrars take the Pledge's audit history into account when applying policy to new devices.</p>
<p id="rfc.section.6.p.3">The MASA server is exposed to DoS attacks wherein attackers claim an unbounded number of devices. Ensuring a Registrar is representative of a valid vendor customer, even without validating ownership of specific Pledge devices, helps to mitigate this. Pledge signatures on the initial voucher request, as forwarded by the Registrar in the prior-signed-voucher field, significantly reduce this risk by ensuring the MASA can confirm proximity between the Pledge and the Registrar making the request. This mechanism is optional to allow for constrained devices.</p>
<p id="rfc.section.6.p.4">It is possible for an attacker to request a voucher from the MASA service directly after the real Registrar obtains an audit log. If the attacker could also force the bootstrapping protocol to reset there is a theoretical opportunity for the attacker to use their voucher to take control of the Pledge but then proceed to enroll with the target domain. Possible prevention mechanisms include:</p>
<p/>

<ul>
  <li>Per device rate limits on the MASA service ensure such timing attacks are difficult.</li>
  <li>The Registrar can repeat the request for audit log information at some time after bootstrapping is complete.</li>
</ul>
<p id="rfc.section.6.p.6">To facilitate logging and administrative oversight the Pledge reports on Voucher parsing status to the Registrar. In the case of a failure this information is informative to a potentially malicious Registar but this is RECOMMENDED anyway because of the operational benefits of an informed administrator in cases where the failure is indicative of a problem.</p>
<p id="rfc.section.6.p.7">To facilitate truely limited clients EST RFC7030 section 3.3.2 requirements that the client MUST support a client authentication model have been reduced in <a href="#reducedsecuritymodes">Section 4</a> to a statement that the Registrar "MAY" choose to accept devices that fail cryptographic authentication. This reflects current (poor) practices in shipping devices without a cryptographic identity that are NOT RECOMMENDED.</p>
<p id="rfc.section.6.p.8">During the provisional period of the connection all HTTP header and content data MUST treated as untrusted data. HTTP libraries are regularly exposed to non-secured HTTP traffic: mature libraries should not have any problems.  </p>
<p id="rfc.section.6.p.9">Pledge's might chose to engage in protocol operations with multiple discovered Registrars in parallel. As noted above they will only do so with distinct nonce values, but the end result could be multple voucher's issued from the MASA if all registrars attempt to claim the device. This is not a failure and the Pledge choses whichever voucher to accept based on internal logic. The Registrar's verifying log information will see multiple entries and take this into account for their analytics purposes.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> Acknowledgements</h1>
<p id="rfc.section.7.p.1">We would like to thank the various reviewers for their input, in particular Brian Carpenter, Toerless Eckert, Fuyu Eleven, Eliot Lear, Sergey Kasatkin, Markus Stenberg, and Peter van der Stok</p>
<h1 id="rfc.references"><a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-anima-autonomic-control-plane">[I-D.ietf-anima-autonomic-control-plane]</b>
      </td>
      <td class="top"><a>Behringer, M.</a>, <a>Eckert, T.</a> and <a>S. Bjarnason</a>, "<a href="http://tools.ietf.org/html/draft-ietf-anima-autonomic-control-plane-06">An Autonomic Control Plane</a>", Internet-Draft draft-ietf-anima-autonomic-control-plane-06, March 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-anima-voucher">[I-D.ietf-anima-voucher]</b>
      </td>
      <td class="top"><a>Watsen, K.</a>, <a>Richardson, M.</a>, <a>Pritikin, M.</a> and <a>T. Eckert</a>, "<a href="http://tools.ietf.org/html/draft-ietf-anima-voucher-03">Voucher Profile for Bootstrapping Protocols</a>", Internet-Draft draft-ietf-anima-voucher-03, June 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="IDevID">[IDevID]</b>
      </td>
      <td class="top"><a>IEEE Standard, </a>, "<a href="http://standards.ieee.org/findstds/standard/802.1AR-2009.html">IEEE 802.1AR Secure Device Identifier</a>", December 2009.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3542">[RFC3542]</b>
      </td>
      <td class="top"><a>Stevens, W.</a>, <a>Thomas, M.</a>, <a>Nordmark, E.</a> and <a>T. Jinmei</a>, "<a href="http://tools.ietf.org/html/rfc3542">Advanced Sockets Application Program Interface (API) for IPv6</a>", RFC 3542, DOI 10.17487/RFC3542, May 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3748">[RFC3748]</b>
      </td>
      <td class="top"><a>Aboba, B.</a>, <a>Blunk, L.</a>, <a>Vollbrecht, J.</a>, <a>Carlson, J.</a> and <a>H. Levkowetz</a>, "<a href="http://tools.ietf.org/html/rfc3748">Extensible Authentication Protocol (EAP)</a>", RFC 3748, DOI 10.17487/RFC3748, June 2004.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3927">[RFC3927]</b>
      </td>
      <td class="top"><a>Cheshire, S.</a>, <a>Aboba, B.</a> and <a>E. Guttman</a>, "<a href="http://tools.ietf.org/html/rfc3927">Dynamic Configuration of IPv4 Link-Local Addresses</a>", RFC 3927, DOI 10.17487/RFC3927, May 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4862">[RFC4862]</b>
      </td>
      <td class="top"><a>Thomson, S.</a>, <a>Narten, T.</a> and <a>T. Jinmei</a>, "<a href="http://tools.ietf.org/html/rfc4862">IPv6 Stateless Address Autoconfiguration</a>", RFC 4862, DOI 10.17487/RFC4862, September 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5280">[RFC5280]</b>
      </td>
      <td class="top"><a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5386">[RFC5386]</b>
      </td>
      <td class="top"><a>Williams, N.</a> and <a>M. Richardson</a>, "<a href="http://tools.ietf.org/html/rfc5386">Better-Than-Nothing Security: An Unauthenticated Mode of IPsec</a>", RFC 5386, DOI 10.17487/RFC5386, November 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5652">[RFC5652]</b>
      </td>
      <td class="top"><a>Housley, R.</a>, "<a href="http://tools.ietf.org/html/rfc5652">Cryptographic Message Syntax (CMS)</a>", STD 70, RFC 5652, DOI 10.17487/RFC5652, September 2009.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5660">[RFC5660]</b>
      </td>
      <td class="top"><a>Williams, N.</a>, "<a href="http://tools.ietf.org/html/rfc5660">IPsec Channels: Connection Latching</a>", RFC 5660, DOI 10.17487/RFC5660, October 2009.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6762">[RFC6762]</b>
      </td>
      <td class="top"><a>Cheshire, S.</a> and <a>M. Krochmal</a>, "<a href="http://tools.ietf.org/html/rfc6762">Multicast DNS</a>", RFC 6762, DOI 10.17487/RFC6762, February 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6763">[RFC6763]</b>
      </td>
      <td class="top"><a>Cheshire, S.</a> and <a>M. Krochmal</a>, "<a href="http://tools.ietf.org/html/rfc6763">DNS-Based Service Discovery</a>", RFC 6763, DOI 10.17487/RFC6763, February 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7030">[RFC7030]</b>
      </td>
      <td class="top"><a>Pritikin, M.</a>, <a>Yee, P.</a> and <a>D. Harkins</a>, "<a href="http://tools.ietf.org/html/rfc7030">Enrollment over Secure Transport</a>", RFC 7030, DOI 10.17487/RFC7030, October 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7228">[RFC7228]</b>
      </td>
      <td class="top"><a>Bormann, C.</a>, <a>Ersue, M.</a> and <a>A. Keranen</a>, "<a href="http://tools.ietf.org/html/rfc7228">Terminology for Constrained-Node Networks</a>", RFC 7228, DOI 10.17487/RFC7228, May 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7951">[RFC7951]</b>
      </td>
      <td class="top"><a>Lhotka, L.</a>, "<a href="http://tools.ietf.org/html/rfc7951">JSON Encoding of Data Modeled with YANG</a>", RFC 7951, DOI 10.17487/RFC7951, August 2016.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.behringer-homenet-trust-bootstrap">[I-D.behringer-homenet-trust-bootstrap]</b>
      </td>
      <td class="top"><a>Behringer, M.</a>, <a>Pritikin, M.</a> and <a>S. Bjarnason</a>, "<a href="http://tools.ietf.org/html/draft-behringer-homenet-trust-bootstrap-02">Bootstrapping Trust on a Homenet</a>", Internet-Draft draft-behringer-homenet-trust-bootstrap-02, February 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-anima-grasp">[I-D.ietf-anima-grasp]</b>
      </td>
      <td class="top"><a>Bormann, C.</a>, <a>Carpenter, B.</a> and <a>B. Liu</a>, "<a href="http://tools.ietf.org/html/draft-ietf-anima-grasp-13">A Generic Autonomic Signaling Protocol (GRASP)</a>", Internet-Draft draft-ietf-anima-grasp-13, June 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-netconf-zerotouch">[I-D.ietf-netconf-zerotouch]</b>
      </td>
      <td class="top"><a>Watsen, K.</a>, <a>Abrahamsson, M.</a> and <a>I. Farrer</a>, "<a href="http://tools.ietf.org/html/draft-ietf-netconf-zerotouch-14">Zero Touch Provisioning for NETCONF or RESTCONF based Management</a>", Internet-Draft draft-ietf-netconf-zerotouch-14, June 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.lear-mud-framework">[I-D.lear-mud-framework]</b>
      </td>
      <td class="top"><a>Lear, E.</a>, "<a href="http://tools.ietf.org/html/draft-lear-mud-framework-00">Manufacturer Usage Description Framework</a>", Internet-Draft draft-lear-mud-framework-00, January 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.richardson-anima-state-for-joinrouter">[I-D.richardson-anima-state-for-joinrouter]</b>
      </td>
      <td class="top"><a>Richardson, M.</a>, "<a href="http://tools.ietf.org/html/draft-richardson-anima-state-for-joinrouter-01">Considerations for stateful vs stateless join router in ANIMA bootstrap</a>", Internet-Draft draft-richardson-anima-state-for-joinrouter-01, July 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="imprinting">[imprinting]</b>
      </td>
      <td class="top"><a>Wikipedia, </a>, "<a href="https://en.wikipedia.org/wiki/Imprinting_(psychology)">Wikipedia article: Imprinting</a>", July 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2473">[RFC2473]</b>
      </td>
      <td class="top"><a>Conta, A.</a> and <a>S. Deering</a>, "<a href="http://tools.ietf.org/html/rfc2473">Generic Packet Tunneling in IPv6 Specification</a>", RFC 2473, DOI 10.17487/RFC2473, December 1998.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7217">[RFC7217]</b>
      </td>
      <td class="top"><a>Gont, F.</a>, "<a href="http://tools.ietf.org/html/rfc7217">A Method for Generating Semantically Opaque Interface Identifiers with IPv6 Stateless Address Autoconfiguration (SLAAC)</a>", RFC 7217, DOI 10.17487/RFC7217, April 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7435">[RFC7435]</b>
      </td>
      <td class="top"><a>Dukhovni, V.</a>, "<a href="http://tools.ietf.org/html/rfc7435">Opportunistic Security: Some Protection Most of the Time</a>", RFC 7435, DOI 10.17487/RFC7435, December 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7575">[RFC7575]</b>
      </td>
      <td class="top"><a>Behringer, M.</a>, <a>Pritikin, M.</a>, <a>Bjarnason, S.</a>, <a>Clemm, A.</a>, <a>Carpenter, B.</a>, <a>Jiang, S.</a> and <a>L. Ciavaglia</a>, "<a href="http://tools.ietf.org/html/rfc7575">Autonomic Networking: Definitions and Design Goals</a>", RFC 7575, DOI 10.17487/RFC7575, June 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="Stajano99theresurrecting">[Stajano99theresurrecting]</b>
      </td>
      <td class="top"><a>Stajano, F.</a> and <a>R. Anderson</a>, "<a href="https://www.cl.cam.ac.uk/~fms27/papers/1999-StajanoAnd-duckling.pdf">The resurrecting duckling: security issues for ad-hoc wireless networks</a>", 1999.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#IPv4operations" id="IPv4operations">IPv4 operations</a></h1>
<h1 id="rfc.appendix.A.1"><a href="#rfc.appendix.A.1">A.1.</a> IPv4 Link Local addresses</h1>
<p id="rfc.section.A.1.p.1">Instead of an IPv6 link-local address, an IPv4 address may be generated using <a href="#RFC3927">[RFC3927]</a>  Dynamic Configuration of IPv4 Link-Local Addresses.  </p>
<p id="rfc.section.A.1.p.2">In the case that an IPv4 Local-Local address is formed, then the bootstrap process would continue as in the IPv6 case by looking for a (circuit) proxy.  </p>
<h1 id="rfc.appendix.A.2"><a href="#rfc.appendix.A.2">A.2.</a> Use of DHCPv4</h1>
<p id="rfc.section.A.2.p.1">The Plege MAY obtain an IP address via DHCP [RFC2131]. The DHCP provided parameters for the Domain Name System can be used to perform DNS operations if all local discovery attempts fail.  </p>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> <a href="#mdnsmethods" id="mdnsmethods">mDNS / DNSSD proxy discovery options</a></h1>
<p id="rfc.section.B.p.1">The Pledge MAY perform DNS-based Service Discovery <a href="#RFC6763">[RFC6763]</a> over Multicast DNS <a href="#RFC6762">[RFC6762]</a> searching for the service "_bootstrapks._tcp.local.". </p>
<p id="rfc.section.B.p.2">To prevent unaccceptable levels of network traffic the congestion avoidance mechanisms specified in <a href="#RFC6762">[RFC6762]</a> section 7 MUST be followed. The Pledge SHOULD listen for an unsolicited broadcast response as described in <a href="#RFC6762">[RFC6762]</a>. This allows devices to avoid announcing their presence via mDNS broadcasts and instead silently join a network by watching for periodic unsolicited broadcast responses.  </p>
<p id="rfc.section.B.p.3">Performs DNS-based Service Discovery [RFC6763] over normal DNS operations. The service searched for is "_bootstrapks._tcp.example.com". In this case the domain "example.com" is discovered as described in <a href="#RFC6763">[RFC6763]</a> section 11.  This method is only available if the host has received a useable IPv4 address via DHCPv4 as suggested in <a href="#IPv4operations">Appendix A</a>.  </p>
<p id="rfc.section.B.p.4">If no local bootstrapks service is located using the GRASP mechanisms, or the above mentioned DNS-based Service Discovery methods the Pledge MAY contact a well known vendor provided bootstrapping server by performing a DNS lookup using a well known URI such as "bootstrapks.vendor-example.com". The details of the URI are vendor specific. Vendors that leverage this method on the Pledge are responsible for providing the bootstrapks service.  </p>
<p id="rfc.section.B.p.5">The current DNS services returned during each query is maintained until bootstrapping is completed. If bootstrapping fails and the Pledge returns to the Discovery state it picks up where it left off and continues attempting bootstrapping.  For example if the first Multicast DNS _bootstrapks._tcp.local response doesn't work then the second and third responses are tried.  If these fail the Pledge moves on to normal DNS-based Service Discovery.  </p>
<h1 id="rfc.appendix.C"><a href="#rfc.appendix.C">Appendix C.</a> <a href="#IPIPmechanism" id="IPIPmechanism">IPIP Join Proxy mechanism</a></h1>
<p id="rfc.section.C.p.1">The Circuit Proxy mechanism suffers from requiring a state on the Join Proxy for each connection that is relayed.  The Circuit Proxy can be considered a kind of Algorithm Gateway [FIND-good-REF].  </p>
<p id="rfc.section.C.p.2">An alternative to proxying at the TCP layer is to selectively forward at the IP layer.  This moves all per-connection to the Join Registrar.  The IPIP tunnel statelessly forwards packets.  This section provides some explanation of some of the details of the Registrar discovery procotol which are not important to Circuit Proxy, and some implementation advice.  </p>
<p id="rfc.section.C.p.3">The IPIP tunnel is described in <a href="#RFC2473">[RFC2473]</a>.  Each such tunnel is considered a unidirectional construct, but two tunnels may be associated to form a bidirectional mechanism.  An IPIP tunnel is setup as follows.  The outer addresses are an ACP address of the Join Proxy, and the ACP address of the Join Registrar.  The inner addresses seen in the tunnel are the link-local addresses of the network on which the join activity is occuring.  </p>
<p id="rfc.section.C.p.4">One way to look at this construct is to consider that the Registrar is extending attaching an interface to the network on which the Join Proxy is physically present.  The Registrar then interacts as if it were present on that network using link-local (fe80::) addresses.  The Join node is unaware that the traffic is being proxied through a tunnel, and does not need any special routing.  </p>
<p id="rfc.section.C.p.5">There are a number of considerations with this mechanism which require cause some minor amounts of complexity.  Note that due to the tunnels, the Registrar sees multiple connections to a fe80::/10 network on not just physical interfaces, but on each of the virtual interfaces represending the tunnels.  </p>
<h1 id="rfc.appendix.C.1"><a href="#rfc.appendix.C.1">C.1.</a> Multiple Join networks on the Join Proxy side</h1>
<p id="rfc.section.C.1.p.1">The Join Proxy will in the general case be a routing device with multiple interfaces.  Even a device as simple as a wifi access point may have wired, and multiple frequencies of wireless interfaces, potentially with multiple ESSIDs.  </p>
<p id="rfc.section.C.1.p.2">Each of these interfaces on the Join Proxy may be seperate L3 routing domains, and therefore will have a unique set of link-local addresses.  An IPIP packet being returned by the Registrar needs to be forwarded to the correct interface, so the Join Proxy needs an additional key to distinguish which network the packet should be returned to.  </p>
<p id="rfc.section.C.1.p.3">The simplest way to get this additional key is to allocate an additional ACP address; one address for each network on which join traffic is occuring.  The Join Proxy SHOULD do a GRASP M_NEG_SYN for each interface which they wish to relay traffic, as this allows the Registrar to do any static tunnel configuration that may be required.  </p>
<h1 id="rfc.appendix.C.2"><a href="#rfc.appendix.C.2">C.2.</a> Automatic configuration of tunnels on Registrar</h1>
<p id="rfc.section.C.2.p.1">The Join Proxy is expected to do a GRASP negotiation with the proxy for each Join Interface that it needs to relay traffic from.  This is to permit Registrars to configure the appropriate virtual interfaces before join traffic arrives.  </p>
<p id="rfc.section.C.2.p.2">A Registrar serving a large number of interfaces may not wish to allocate resources to every interface at all times, but can instead dynamically allocate interfaces.  It can do this by monitoring IPIP traffic that arrives on it's ACP interface, and when packets arrive from new Join Proxys, it can dynamically configure virtual interfaces.  </p>
<p id="rfc.section.C.2.p.3">A more sophisticated Registrar willing to modify the behaviour of it's TCP and UDP stack could note the IPIP traffic origination in the socket control block and make information available to the TCP layer (for HTTPS connections), or to the the application (for CoAP connections) via a proprietary extension to the socket API.  </p>
<h1 id="rfc.appendix.C.3"><a href="#rfc.appendix.C.3">C.3.</a> Proxy Neighbor Discovery by Join Proxy</h1>
<p id="rfc.section.C.3.p.1">The Join Proxy MUST answer neighbor discovery messages for the address given by the Registrar as being it's link-local address.  The Join Proxy must also advertise this address as the address to which to connect to when advertising it's existence.  </p>
<p id="rfc.section.C.3.p.2">This proxy neighbor discovery means that the pledge will create TCP and UDP connections to the correct Registrar address.  This matters as the TCP and UDP pseudo-header checksum includes the destination address, and for the proxy to remain completely stateless, it must not be necessary for the checksum to be updated.  </p>
<h1 id="rfc.appendix.C.4"><a href="#rfc.appendix.C.4">C.4.</a> Use of connected sockets; or IP_PKTINFO for CoAP on Registrar</h1>
<p id="rfc.section.C.4.p.1">TCP connections on the registrar SHOULD properly capture the ifindex of the incoming connection into the socket structure.  This is normal IPv6 socket API processing.  The outgoing responses will go out on the same (virtual) interface by ifindex.  </p>
<p id="rfc.section.C.4.p.2">When using UDP sockets with CoAP, the application will have to pay attention to the incoming ifindex on the socket.  Access to this information is available using the IP_PKTINFO auxiliary extension which is a standard part of the IPv6 sockets API.  </p>
<p id="rfc.section.C.4.p.3">A registrar application could, after receipt of an initial CoAP message from the Pledge, create a connected UDP socket (including the ifindex information).  The kernel would then take care of accurate demultiplexing upon receive, and subsequent transmission to the correct interface.  </p>
<h1 id="rfc.appendix.C.5"><a href="#rfc.appendix.C.5">C.5.</a> Use of socket extension rather than virtual interface</h1>
<p id="rfc.section.C.5.p.1">Some operating systems on which a Registrar need be implemented may find need for a virtual interface per Join Proxy to be problematic. There are other mechanism which can make be done.  </p>
<p id="rfc.section.C.5.p.2">If the IPIP decapsulator can mark the (SYN) packet inside the kernel with the address of the Join Proxy sending the traffic, then an interface per Join Proxy may not be needed.  The outgoing path need just pay attention to this extra information and add an appropriate IPIP header on outgoing.  A CoAP over UDP mechanism may need to expose this extra information to the application as the UDP sockets are often not connected, and the application will need to specify the outgoing path on each packet send.  </p>
<p id="rfc.section.C.5.p.3">Such an additional socket mechanism has not been standardized.  Terminating L2TP connections over IPsec transport mode suffers from the same challenges.  </p>
<h1 id="rfc.appendix.D"><a href="#rfc.appendix.D">Appendix D.</a> To be deprecated: Consolidation remnants</h1>
<p id="rfc.section.D.p.1">[[EDNOTE: As per working group feedback there were multiple instances where this document repeated itself. To address this we have moved all text to this appendix and restored only one copy of each normative discussion. The next pass will reduce and delete this appendix to '0'; although some may be maintained in a design considerations appendix.]]</p>
<h1 id="rfc.appendix.D.1"><a href="#rfc.appendix.D.1">D.1.</a> Functional Overview</h1>
<p id="rfc.section.D.1.p.1">Entities behave in an autonomic fashion. They discover each other and autonomically bootstrap into a key infrastructure delineating the autonomic domain. See <a href="#RFC7575">[RFC7575]</a> for more information.</p>
<p id="rfc.section.D.1.p.2">This section details the state machine and operational flow for each of the main three entities. The pledge, the domain (primarily a Registrar) and the MASA service.</p>
<p id="rfc.section.D.1.p.3">A representative flow is shown in Figure 2:</p>
<pre>
+--------+         +---------+    +------------+     +------------+
| Pledge |         | Circuit |    | Domain     |     | Vendor     |
|        |         | Proxy   |    | Registrar  |     | Service    |
|        |         |         |    |            |     | (Internet  |
+--------+         +---------+    +------------+     +------------+
  |                     |                   |                    |
  |&lt;-RFC3927 IPv4 adr   | Appendix A        |                    |
or|&lt;-RFC4862 IPv6 adr   |                   |                    |
  |                     |                   |                    |
  |--------------------&gt;|                   |                    |
  | optional: mDNS query| Appendix B        |                    |
  | RFC6763/RFC6762     |                   |                    |
  |                     |                   |                    |
  |&lt;--------------------|                   |                    |
  | GRASP M_FLOOD       |                   |                    |
  |   periodic broadcast|                   |                    |
  |                     |                   |                    |
  |&lt;-------------------&gt;C&lt;-----------------&gt;|                    |
  |              TLS via the Circuit Proxy  |                    |
  |&lt;--Registrar TLS server authentication---|                    |
[PROVISIONAL accept of server cert]         |                    |
  P---X.509 client authentication----------&gt;|                    |
  P                     |                   |                    |
  P---Request Voucher (include nonce)------&gt;|                    |
  P                     |                   |                    |
  P                     |       /---&gt;       |                    |
  P                     |       |      [accept device?]          |
  P                     |       |      [contact Vendor]          |
  P                     |       |           |--Pledge ID--------&gt;|
  P                     |       |           |--Domain ID--------&gt;|
  P                     |       |           |--optional:nonce---&gt;|
  P                     |       |           |     [extract DomainID]
  P                     |       |           |                    |
  P                     |    optional:      |     [update audit log]
  P                     |       |can        |                    |
  P                     |       |occur      |                    |
  P                     |       |in         |                    |
  P                     |       |advance    |                    |
  P                     |       |           |                    |
  P                     |       |           |&lt;-device audit log--|
  P                     |       |           |&lt;- voucher ---------|
  P                     |       \----&gt;      |                    |
  P                     |                   |                    |
  P                     |       [verify audit log and voucher]   |
  P                     |                   |                    |
  P&lt;------voucher---------------------------|                    |
[verify voucher ]       |                   |                    |
[verify provisional cert|                   |                    |
  |                     |                   |                    |
  |&lt;---------------------------------------&gt;|                    |
  | Continue with RFC7030 enrollment        |                    |
  | using now bidirectionally authenticated |                    |
  | TLS session.        |                   |                    |
  |                     |                   |                    |
  |                     |                   |                    |
  |                     |                   |                    |
</pre>
<p>Figure 2</p>
<p id="rfc.section.D.1.p.4">[[UNRESOLVED:need to restore some functional overview section for all these diagrams]]In order to obtain a Voucher and associated logs a Registrar contacts the MASA service Service using REST calls:</p>
<pre>
           +-----------+ +----------+ +-----------+ +----------+
           | New       | | Circuit  | |           | |          |
           | Entity    | | Proxy    | | Registrar | | Vendor   |
           |           | |          | |           | |          |
           ++----------+ +--+-------+ +-----+-----+ +--------+-+
            |               |               |                |
            |               |               |                |
            |   TLS hello   |  TLS hello    |                |
Establish   +---------------C---------------&gt;                |
TLS         |               |               |                |
connection  |               | Server Cert   |                |
            &lt;---------------C---------------+                |
            | Client Cert   |               |                |
            +---------------C---------------&gt;                |
            |               |               |                |
HTTP REST   | POST /requestvoucher          |                |
Data        +--------------------nonce------&gt;                |
            |               .               | /requestvoucher|
            |               .               +----------------&gt;
            |                               &lt;----------------+
            |                               | /requestlog    |
            |                               +----------------&gt;
            |            voucher            &lt;----------------+
            &lt;-------------------------------+                |
            | (optional config information) |                |
            |               .               |                |
            |               .               |                |
</pre>
<p>Figure 8</p>
<p id="rfc.section.D.1.p.5">In some use cases the Registrar may need to contact the Vendor in advanced, for example when the target network is air-gapped. The nonceless request format is provided for this and the resulting flow is slightly different. The security differences associated with not knowing the nonce are discussed below:</p>
<pre>
           +-----------+ +----------+ +-----------+ +----------+
           | New       | | Circuit  | |           | |          |
           | Entity    | | Proxy    | | Registrar | | Vendor   |
           |           | |          | |           | |          |
           ++----------+ +--+-------+ +-----+-----+ +--------+-+
            |               |               |                |
            |               |               |                |
            |               |               | /requestvoucher|
            |               |  (nonce       +----------------&gt;
            |               |  unknown)     &lt;----------------+
            |               |               | /requestlog    |
            |               |               +----------------&gt;
            |               |               &lt;----------------+
            |   TLS hello   |  TLS hello    |                |
Establish   +---------------C---------------&gt;                |
TLS         |               |               |                |
connection  |               | Server Cert   |                |
            &lt;---------------C---------------+                |
            | Client Cert   |               |                |
            |               |               |                |
HTTP REST   | POST /requestvoucher          |                |
Data        +----------------------nonce----&gt;   (discard     |
            |            voucher            |   nonce)       |
            &lt;-------------------------------+                |
            | (optional config information) |                |
            |               .               |                |
            |               .               |                |
</pre>
<p>Figure 9</p>
<p/>
<p/>
<h1 id="rfc.appendix.D.1.1"><a href="#rfc.appendix.D.1.1">D.1.1.</a> Behavior of a Pledge</h1>
<p id="rfc.section.D.1.1.p.1">A pledge that has not yet been bootstrapped attempts to find a local domain and join it. A pledge [[RESOLVED:MUST NOT]] automatically initiate bootstrapping if it has already been configured or is in the process of being configured.</p>
<p id="rfc.section.D.1.1.p.2">States of a pledge are as follows:</p>
<p/>
<pre>
             +--------------+
             |   Factory    |
             |   default    |
             +------+-------+
                    |
             +------v-------+
             |  Discover    |
+------------&gt;              |
|            +------+-------+
|                   |
|            +------v-------+
|            |  Identity    |
^------------+              |
| rejected   +------+-------+
|                   |
|            +------v-------+
|            | Request      |
|            | Join         |
|            +------+-------+
|                   |
|            +------v-------+
|            |  Imprint     |   Optional
^------------+              &lt;--+Manual input (Appendix C)
| Bad Vendor +------+-------+
| response          |
|            +------v-------+
|            |  Enroll      |
^------------+              |
| Enroll     +------+-------+
| Failure           |
|            +------v-------+
|            |  Enrolled    |
^------------+              |
 Factory     +--------------+
 reset

</pre>
<p>Figure 3</p>
<p/>
<p id="rfc.section.D.1.1.p.5">State descriptions for the pledge are as follows:</p>
<p/>

<ol>
  <li>Discover a communication channel to a Registrar.</li>
  <li>Identify itself. This is done by presenting an X.509 IDevID credential to the discovered Registrar (via the Proxy) in a TLS handshake. (The Registrar credentials are only provisionally accepted at this time).</li>
  <li>Requests to Join the discovered Registrar. A unique nonce [[RESOLVED:can be]] included ensuring that any responses can be associated with this particular bootstrapping attempt.</li>
  <li>Imprint on the Registrar. This requires verification of the vendor service provided voucher. A voucher contains sufficient information for the Pledge to complete authentication of a Registrar. (It enables the Pledge to finish authentication of the Registrar TLS server certificate).</li>
  <li>Enroll. By accepting the domain specific information from a Registrar, and by obtaining a domain certificate from a Registrar using a standard enrollment protocol, e.g. Enrollment over Secure Transport (EST) <a href="#RFC7030">[RFC7030]</a>.</li>
  <li>The Pledge is now a member of, and can be managed by, the domain and will only repeat the discovery aspects of bootstrapping if it is returned to factory default settings.</li>
</ol>

<p>The following sections describe each of these steps in more detail.</p>
<h1 id="rfc.appendix.D.1.1.1"><a href="#rfc.appendix.D.1.1.1">D.1.1.1.</a> <a href="#ProxyDiscovery" id="ProxyDiscovery">Discovery</a></h1>
<p id="rfc.section.D.1.1.1.p.1">[[RESOLVED:TEXT moved up into above]]</p>
<h1 id="rfc.appendix.D.1.1.2"><a href="#rfc.appendix.D.1.1.2">D.1.1.2.</a> <a href="#identity" id="identity">Identity</a></h1>
<p id="rfc.section.D.1.1.2.p.1">The Pledge identifies itself during the communication protocol handshake. If the client identity is rejected (that is, the TLS handshake does not complete) the Pledge repeats the Identity process using the next proxy or discovery method available.  </p>
<p id="rfc.section.D.1.1.2.p.2">[[RESOLVED: need normative statement in protocol section]] The bootstrapping protocol server is not initially authenticated.  Thus the connection is provisional and all data received is untrusted until sufficiently validated even though it is over a TLS connection. This is aligned with the existing provisional mode of EST <a href="#RFC7030">[RFC7030]</a> during s4.1.1 "Bootstrap Distribution of CA Certificates". See <a href="#VoucherResponse">Section 3.4</a> for more information about when the TLS connection authentication is completed.</p>
<p id="rfc.section.D.1.1.2.p.3">[[RESOLVED:]]All security associations established are between the new device and the Bootstrapping server regardless of proxy operations.</p>
<h1 id="rfc.appendix.D.1.1.2.1"><a href="#rfc.appendix.D.1.1.2.1">D.1.1.2.1.</a> Concurrent attempts to join</h1>
<p id="rfc.section.D.1.1.2.1.p.1">[[RESOLVED: by dropping this text. the "priority mechanism" is unspecified thus any discussion is unclear. Not only that once an initial request is sent to the registrar the question of multiple MASA interactions has already occurred. Nothing breaks if implementations do this. I've added text to the security considerations indicating the end result (MASA entries that might be ignored by the device but which confuse the end administrator)]] The Pledge MAY attempt multiple mechanisms concurrently, but if it does so, it MUST wait in the provisional state until all mechanisms have either succeeded or failed, and then MUST proceed with the highest priority mechanism which has succeed.  To proceed beyond this point, specifically, to provide a nonce, could result in the MASA gratuitously auditing a connection.  </p>
<h1 id="rfc.appendix.D.1.1.3"><a href="#rfc.appendix.D.1.1.3">D.1.1.3.</a> Request Join</h1>
<p id="rfc.section.D.1.1.3.p.1">The Pledge POSTs a request to join the domain to the Bootstrapping server. This request contains a Pledge generated nonce and informs the Bootstrapping server which imprint methods the Pledge will accept.</p>
<p id="rfc.section.D.1.1.3.p.2">The nonce ensures the Pledge can verify that responses are specific to this bootstrapping attempt. This minimizes the use of global time and provides a substantial benefit for devices without a valid clock.</p>
<h1 id="rfc.appendix.D.1.1.3.1"><a href="#rfc.appendix.D.1.1.3.1">D.1.1.3.1.</a> Redirects during the Join Process</h1>
<p id="rfc.section.D.1.1.3.1.p.1">[[RESOVED via current root protocol discussion. reference to mdnsmethods is dropped]] EST <a href="#RFC7030">[RFC7030]</a> describes situations where the bootstrapping server MAY redirect the client to an alternate server via a 3xx status code.   Such redirects MAY be accepted if the pledge has used the methods described in <a href="#mdnsmethods">Appendix B</a>, in combination with an implicit trust anchor.  Redirects during the provisional period are otherwise unstrusted, and MUST cause a failure.  </p>
<h1 id="rfc.appendix.D.1.1.4"><a href="#rfc.appendix.D.1.1.4">D.1.1.4.</a> <a href="#AcceptDomain" id="AcceptDomain">Imprint</a></h1>
<p id="rfc.section.D.1.1.4.p.1">The Pledge validates the voucher and accepts the Registrar ID.  The provisional TLS connection is validated using the Registrar ID from the voucher.</p>
<h1 id="rfc.appendix.D.1.1.5"><a href="#rfc.appendix.D.1.1.5">D.1.1.5.</a> <a href="#timeunknownAPPENDIX" id="timeunknownAPPENDIX">Lack of realtime clock APPENDIX</a></h1>
<p id="rfc.section.D.1.1.5.p.1">[[RESOVED: entire section promoted back into the main text]]</p>
<p id="rfc.section.D.1.1.5.p.2">Many devices when bootstrapping do not have knowledge of the current time. Mechanisms like Network Time Protocols can not be secured until bootstrapping is complete. Therefore bootstrapping is defined in a method that does not require knowledge of the current time.</p>
<p id="rfc.section.D.1.1.5.p.3">Unfortunately there are moments during bootstrapping when certificates are verified, such as during the TLS handshake, where validity periods are confirmed. This paradoxical "catch-22" is resolved by the Pledge maintaining a concept of the current "window" of presumed time validity that is continually refined throughout the bootstrapping process as follows:</p>
<p/>

<ul>
  <li>Initially the Pledge does not know the current time.</li>
  <li>During Pledge authentiation by the Registrar a realtime clock can be used by the Registrar. This bullet expands on a closely related issue regarding Pledge lifetimes. RFC5280 indicates that long lived Pledge certifiates "SHOULD be assigned the GeneralizedTime value of 99991231235959Z" <a href="#RFC7030">[RFC7030]</a> so the Registrar MUST support such lifetimes and SHOULD support ignoring Pledge lifetimes if they did not follow the RFC5280 recommendations.</li>
  <li>The Pledge authenticates the voucher presented to it. During this authentication the Pledge ignores certificate lifetimes (by necessity because it does not have a clock).  The voucher itself SHOULD contain the nonce included in the original request which proves the voucher is fresh.</li>
  <li>Once the voucher is accepted the validity period of the domainCAcert in the voucher (see <a href="#VoucherResponse">Section 3.4</a>) now serves as a valid time window. Any subsequent certificate validity periods checked during RFC5280 path validation MUST occur within this window.</li>
  <li>When accepting an enrollment certificate the validity period within the new certificate is assumed to be valid by the Pledge.  The Pledge is now willing to use this credential for client authentication.</li>
</ul>
<h1 id="rfc.appendix.D.1.1.6"><a href="#rfc.appendix.D.1.1.6">D.1.1.6.</a> Enrollment</h1>
<p id="rfc.section.D.1.1.6.p.1">As the final step of bootstrapping a Registrar helps to issue a domain specific credential to the Pledge. For simplicity in this document, a Registrar primarily facilitates issuing a credential by acting as an RFC5280 Registration Authority for the Domain Certification Authority.</p>
<p id="rfc.section.D.1.1.6.p.2">Enrollment proceeds as described in <a href="#RFC7030">[RFC7030]</a>. Authentication of the EST server is done using the Voucher rather than the methods defined in EST.</p>
<p id="rfc.section.D.1.1.6.p.3">[[RESOLVED: moved to protocol discussion]]Once the Voucher is received, as specified in this document, the client has sufficient information to leverage the existing communication channel with a Registrar to continue an EST RFC7030 enrollment. Enrollment picks up at RFC7030 section 4.1.1.  bootstrapping where the Voucher provides the "out-of-band" CA certificate fingerprint (in this case the full CA certificate) such that the client can now complete the TLS server authentication. At this point the client continues with EST enrollment operations including "CA Certificates Request", "CSR Attributes" and "Client Certificate Request" or "Server-Side Key Generation".</p>
<p id="rfc.section.D.1.1.6.p.4">[[RESOLVED: included into EST discussion]]For the purposes of creating the ANIMA Autonomic Control Plane, the contents of the new certificate MUST be carefully specified.  <a href="#I-D.ietf-anima-autonomic-control-plane">[I-D.ietf-anima-autonomic-control-plane]</a> section 5.1.1 contains details.  The Registrar MUST provide the the correct ACP information to populate the subjectAltName / rfc822Name field in the "CSR Attributes" step.  </p>
<h1 id="rfc.appendix.D.1.1.7"><a href="#rfc.appendix.D.1.1.7">D.1.1.7.</a> Being Managed</h1>
<p id="rfc.section.D.1.1.7.p.1">[[RESOLVED: by slight change to introduction text.]] Functionality to provide generic "configuration" information is supported. The parsing of this data and any subsequent use of the data, for example communications with a Network Management System is out of scope but is expected to occur after bootstrapping enrollment is complete. This ensures that all communications with management systems which can divulge local security information (e.g. network topology or raw key material) is secured using the local credentials issued during enrollment.</p>
<p id="rfc.section.D.1.1.7.p.2">The Pledge uses bootstrapping to join only one domain. Management by multiple domains is out-of-scope of bootstrapping. After the device has successfully joined a domain and is being managed it is plausible that the domain can insert credentials for other domains depending on the device capabilities.</p>
<p id="rfc.section.D.1.1.7.p.3">See <a href="#PostEnrollment">Appendix D.1.5</a>.</p>
<h1 id="rfc.appendix.D.1.2"><a href="#rfc.appendix.D.1.2">D.1.2.</a> <a href="#proxybehaviour" id="proxybehaviour">Behavior of a Join Proxy</a></h1>
<p id="rfc.section.D.1.2.p.1">The role of the Proxy is to facilitate communications. The Proxy forwards packets between the Pledge and a Registrar that has been configured on the Proxy.  </p>
<p id="rfc.section.D.1.2.p.2">[[UNRESOLVED: since proxy behavior is not visible we can limit ourselves to discussion of what the protocol does to enable/faciliate a theoretical proxy]]The Proxy does not terminate the TLS handshake.</p>
<p id="rfc.section.D.1.2.p.3">[[UNRESOLVED: this is an anima architecture requirement to use BRSKI? move to there?]] A Proxy is always assumed even if it is directly integrated into a Registrar.  (In a completely autonomic network, the Registrar MUST provide proxy functionality so that it can be discovered, and the network can grow concentrically around the Registrar) </p>
<p id="rfc.section.D.1.2.p.4">As a result of the Proxy Discovery process in section <a href="#ProxyDiscovery">Appendix D.1.1.1</a>, the port number exposed by the proxy does not need to be well known, or require an IANA allocation.</p>
<p id="rfc.section.D.1.2.p.5">If the Proxy joins an Autonomic Control Plane (<a href="#I-D.ietf-anima-autonomic-control-plane">[I-D.ietf-anima-autonomic-control-plane]</a>) it SHOULD use Autonomic Control Plane secured GRASP (<a href="#I-D.ietf-anima-grasp">[I-D.ietf-anima-grasp]</a>) to discovery the Registrar address and port.  As part of the discovery process, the proxy mechanism (Circuit Proxy vs IPIP encapsulation) is agreed to between the Registrar and Join Proxy.  </p>
<p id="rfc.section.D.1.2.p.6">For the IPIP encapsulation methods, the port announced by the Proxy MUST be the same as on the registrar in order for the proxy to remain stateless.</p>
<p id="rfc.section.D.1.2.p.7">In order to permit the proxy functionality to be implemented on the maximum variety of devices the chosen mechanism SHOULD use the minimum amount of state on the proxy device. While many devices in the ANIMA target space will be rather large routers, the proxy function is likely to be implemented in the control plane CPU of such a device, with available capabilities for the proxy function similar to many class 2 IoT devices.</p>
<p id="rfc.section.D.1.2.p.8">The document <a href="#I-D.richardson-anima-state-for-joinrouter">[I-D.richardson-anima-state-for-joinrouter]</a> provides a more extensive analysis of the alternative proxy methods.</p>
<h1 id="rfc.appendix.D.1.2.1"><a href="#rfc.appendix.D.1.2.1">D.1.2.1.</a> <a href="#coapconnection" id="coapconnection">CoAP connection to Registrar</a></h1>
<p id="rfc.section.D.1.2.1.p.1">[[RESOLVED:this section thus removed]]The CoAP mechanism was depreciated.</p>
<h1 id="rfc.appendix.D.1.2.2"><a href="#rfc.appendix.D.1.2.2">D.1.2.2.</a> HTTPS proxy connection to Registrar</h1>
<p id="rfc.section.D.1.2.2.p.1">The proxy SHOULD also provide one of: an IPIP encapsulation of HTTP traffic on TCP port TBD to the registrar, or a TCP circuit proxy that connects the Pledge to a Registrar.</p>
<p id="rfc.section.D.1.2.2.p.2">When the Proxy provides a circuit proxy to a Registrar the Registrar MUST accept HTTPS connections.</p>
<p id="rfc.section.D.1.2.2.p.3">When the Proxy provides a stateless IPIP encapsulation to a Registrar, then the Registrar will have to perform IPIP decapsulation, remembering the originating outer IPIP source address in order to qualify the inner link-local address. This is a kind of encapsulation and processing which is similar in many ways to how mobile IP works.</p>
<p id="rfc.section.D.1.2.2.p.4">Being able to connect a TCP (HTTP) or UDP (CoAP) socket to a link-local address with an encapsulated IPIP header requires API extensions beyond <a href="#RFC3542">[RFC3542]</a> for UDP use, and requires a form of connection latching (see section 4.1 of <a href="#RFC5386">[RFC5386]</a> and all of <a href="#RFC5660">[RFC5660]</a>, except that a simple IPIP tunnel is used rather than an IPsec tunnel).</p>
<h1 id="rfc.appendix.D.1.3"><a href="#rfc.appendix.D.1.3">D.1.3.</a> Behavior of the Registrar</h1>
<p id="rfc.section.D.1.3.p.1">A Registrar listens for Pledges and determines if they can join the domain. A Registrar obtains a Voucher from the MASA service and delivers them to the Pledge as well as facilitating enrollment with the domain PKI.</p>
<p id="rfc.section.D.1.3.p.2">[[RESOLVED: moved to discovery discussion]] A Registrar is typically configured manually.  When the Registrar joins an Autonomic Control Plane (<a href="#I-D.ietf-anima-autonomic-control-plane">[I-D.ietf-anima-autonomic-control-plane]</a>) it MUST respond to GRASP (<a href="#I-D.ietf-anima-grasp">[I-D.ietf-anima-grasp]</a>) M_DISCOVERY message. See <a href="#discovery">Section 3.1.2</a> </p>
<p id="rfc.section.D.1.3.p.3">Registrar behavior is as follows:</p>
<p/>
<pre>
Contacted by Pledge
        +
        |
+-------v----------+
| Entity           | fail?
| Authentication   +---------+
+-------+----------+         |
        |                    |
+-------v----------+         |
| Entity           | fail?   |
| Authorization    +---------&gt;
+-------+----------+         |
        |                    |
+-------v----------+         |
| Claiming the     | fail?   |
| Entity           +---------&gt;
+-------+----------+         |
        |                    |
+-------v----------+         |
| Log Verification | fail?   |
|                  +---------&gt;
+-------+----------+         |
        |                    |
+-------v----------+    +----v-------+
| Forward          |    |            |
| Voucher          |    | Reject     |
| to the Pledge    |    | Device     |
|                  |    |            |
+------------------+    +------------+
</pre>
<p>Figure 4</p>
<h1 id="rfc.appendix.D.1.3.1"><a href="#rfc.appendix.D.1.3.1">D.1.3.1.</a> <a href="#entityauthentication" id="entityauthentication">Pledge Authentication</a></h1>
<p id="rfc.section.D.1.3.1.p.1">The applicable authentication methods detailed in EST <a href="#RFC7030">[RFC7030]</a> are:</p>
<p/>

<ul>
  <li>[[RESOLVED:pointed out in protocol details]]the use of an X.509 IDevID credential during the TLS client authentication,</li>
  <li>or the use of a secret that is transmitted out of band between the Pledge and a Registrar (this use case is not autonomic).</li>
</ul>

<p>In order to validate the X.509 IDevID credential a Registrar maintains a database of vendor trust anchors (e.g. vendor root certificates or keyIdentifiers for vendor root public keys).  For user interface purposes this database can be mapped to colloquial vendor names. Registrars can be shipped with the trust anchors of a significant number of third-party vendors within the target market.</p>
<h1 id="rfc.appendix.D.1.3.2"><a href="#rfc.appendix.D.1.3.2">D.1.3.2.</a> <a href="#AcceptingTheEntity" id="AcceptingTheEntity">Pledge Authorization</a></h1>
<p id="rfc.section.D.1.3.2.p.1">[[UNRESOLVED: this is referenced above as how the MASA does authorization. That is incorrect]]</p>
<p id="rfc.section.D.1.3.2.p.2">In a fully automated network all devices must be securely identified and authorized to join the domain.</p>
<p id="rfc.section.D.1.3.2.p.3">A Registrar accepts or declines a request to join the domain, based on the authenticated identity presented. Automated acceptance criteria include:</p>
<p/>

<ul>
  <li>allow any device of a specific type (as determined by the X.509 IDevID),</li>
  <li>allow any device from a specific vendor (as determined by the X.509 IDevID),</li>
  <li>allow a specific device from a vendor (as determined by the X.509 IDevID) against a domain white list. (The mechanism for checking a shared white list potentially used by multiple Registrars is out of scope).</li>
</ul>
<p id="rfc.section.D.1.3.2.p.5">[[RESOLVED: this looks like good text to include in above]]To look the Pledge up in a domain white list a consistent method for extracting device identity from the X.509 certificate is required. RFC6125 describes Domain-Based Application Service identity but here we require Vendor Device-Based identity. The subject field's DN encoding MUST include the "serialNumber" attribute with the device's unique serial number. In the language of RFC6125 this provides for a SERIALNUM-ID category of identifier that can be included in a certificate and therefore that can also be used for matching purposes. The SERIALNUM-ID whitelist is collated according to vendor trust anchor since serial numbers are not globally unique.</p>
<p id="rfc.section.D.1.3.2.p.6">[[RESOLVED: into log request]]The Registrar MUST use the vendor provided MASA service to verify that the device's history log does not include unexpected Registrars. If a device had previously registered with another domain, a Registrar of that domain would show in the log.</p>
<p id="rfc.section.D.1.3.2.p.7">[[RESOLVED: est integration section used 'SHOULD']]The authorization performed during BRSKI MAY be used for EST enrollment requests by proceeding with EST enrollment using the authenticated and authorized TLS connection. This minimizes the number of cryptographic and protocol operations necessary to complete bootstrapping of the local key infrastructure.</p>
<h1 id="rfc.appendix.D.1.3.3"><a href="#rfc.appendix.D.1.3.3">D.1.3.3.</a> Claiming the Pledge</h1>
<p id="rfc.section.D.1.3.3.p.1">Claiming an pledge establishes an audit log at the MASA server and provides a Registrar with proof, in the form of the Voucher, that the log entry has been inserted. As indicated in <a href="#AcceptDomain">Appendix D.1.1.4</a> a Pledge will only proceed with bootstrapping if a Voucher has been received.  The Pledge therefore enforces that bootstrapping only occurs if the claim has been logged. There is no requirement for the vendor to definitively know that the device is owned by the Registrar.</p>
<p id="rfc.section.D.1.3.3.p.2">The Registrar obtains the MASA URI via static configuration or by extracting it from the X.509 IDevID credential. See <a href="#IDevIDextension">Section 2.2</a>.</p>
<p id="rfc.section.D.1.3.3.p.3">During initial bootstrapping the Pledge provides a nonce specific to the particular bootstrapping attempt. [[RESOLVED: to resolve this I updated many points where vouchers are referenced]]The Registrar SHOULD include this nonce when claiming the Pledge from the MASA service.  Claims from an unauthenticated Registrar are only serviced by the MASA resource if a nonce is provided.</p>
<p id="rfc.section.D.1.3.3.p.4">The Registrar can claim a Pledge that is offline by forming the request using the entities unique identifier and not including a nonce in the claim request. Vouchers obtained in this way do not have a lifetime and they provide a permanent method for the domain to claim the device. Evidence of such a claim is provided in the audit log entries available to any future Registrar. Such claims reduce the ability for future domains to secure bootstrapping and therefore the Registrar MUST be authenticated by the MASA service although no requirement is implied that the MASA associates this authentication with ownership.</p>
<p id="rfc.section.D.1.3.3.p.5">An Ownership Voucher requires the vendor to definitively know that a device is owned by a specific domain. The method used to "claim" this are out-of-scope. A MASA ignores or reports failures when an attempt is made to claim a device that has a an Ownership Voucher.</p>
<h1 id="rfc.appendix.D.1.3.4"><a href="#rfc.appendix.D.1.3.4">D.1.3.4.</a> Log Verification</h1>
<p id="rfc.section.D.1.3.4.p.1">A Registrar requests the log information for the Pledge from the MASA service. The log is verified to confirm that the following is true to the satisfaction of a Registrar's configured policy:</p>
<p/>

<ul>
  <li>Any nonceless entries in the log are associated with domainIDs recognized by the registrar.</li>
  <li>Any nonce'd entries are older than when the domain is known to have physical possession of the Pledge or that the domainIDs are recognized by the registrar.</li>
</ul>

<p>If any of these criteria are unacceptable to a Registrar the entity is rejected. [[RESOLVED: moved to main body]] A Registrar MAY be configured to ignore the history of the device but it is RECOMMENDED that this only be configured if hardware assisted NEA [RFC5209] is supported.</p>
<p id="rfc.section.D.1.3.4.p.3">[[RESOLVED: added to main text]]This document specifies a simple log format as provided by the MASA service to the registar. This format could be improved by distributed consensus technologies that integrate vouchers with a technologies such as block-chain or hash trees or the like. Doing so is out of the scope of this document but are anticipated improvements for future work.</p>
<h1 id="rfc.appendix.D.1.4"><a href="#rfc.appendix.D.1.4">D.1.4.</a> Behavior of the MASA Service</h1>
<p id="rfc.section.D.1.4.p.1">[[UNRESOLVED: primary value of keeping this discussion is to distinguish between registrar and masa particularly wrt to the protocol functions provided. perhaps add statements in each protocol entry "provided by masa" etc?]]</p>
<p id="rfc.section.D.1.4.p.2">The Manufacturer Authorized Signing Authority service is directly provided by the manufacturer, or can be provided by a third party the manufacturer authorizes. It is a cloud resource. The MASA service provides the following functionalities to Registrars:</p>
<p/>

<dl>
  <dt>Issue Vouchers:</dt>
  <dd style="margin-left: 8">In response to Registrar requests the MASA service issues vouchers. Depending on the MASA policy the Registrar claim of device ownership is either accepted or verified using out-of-scope methods (that are expected to improve over time).</dd>
  <dt>Log Vouchers Issued:</dt>
  <dd style="margin-left: 8">When a voucher is issued the act of issuing it includes updating the certifiable logs. Future work to enhance and distribute these logs is out-of-scope but expected over time.</dd>
  <dt>Provide Logs:</dt>
  <dd style="margin-left: 8">As a baseline implementation of the certified logging mechanism the MASA is repsonsible for reporting logged information. The current method involves trusting the MASA. Other logging methods where the MASA is less trusted are expected to be developed over time.</dd>
</dl>
<h1 id="rfc.appendix.D.1.5"><a href="#rfc.appendix.D.1.5">D.1.5.</a> <a href="#PostEnrollment" id="PostEnrollment">Leveraging the new key infrastructure / next steps</a></h1>
<p id="rfc.section.D.1.5.p.1">As the devices have a common trust anchor, device identity can be securely established, making it possible to automatically deploy services across the domain in a secure manner.</p>
<p id="rfc.section.D.1.5.p.2">Examples of services:</p>

<ul>
  <li>Device management.</li>
  <li>Routing authentication.</li>
  <li>Service discovery.</li>
</ul>
<h1 id="rfc.appendix.D.1.5.1"><a href="#rfc.appendix.D.1.5.1">D.1.5.1.</a> <a href="#boundary" id="boundary">Network boundaries</a></h1>
<p id="rfc.section.D.1.5.1.p.1">When a device has joined the domain, it can validate the domain membership of other devices. This makes it possible to create trust boundaries where domain members have higher level of trusted than external devices. Using the autonomic User Interface, specific devices can be grouped into to sub domains and specific trust levels can be implemented between those.</p>
<h1 id="rfc.appendix.D.1.6"><a href="#rfc.appendix.D.1.6">D.1.6.</a> Interactions with Network Access Control</h1>
<p id="rfc.section.D.1.6.p.1">[[RESOLVED: via paragraph in 'scope of solution' discussion.]]</p>
<p id="rfc.section.D.1.6.p.2">The assumption is that Network Access Control (NAC) completes using the Pledge 's X.509 IDevID credentials and results in the device having sufficient connectivity to discovery and communicate with the proxy. Any additional connectivity or quarantine behavior by the NAC infrastructure is out-of-scope. After the devices has completed bootstrapping the mechanism to trigger NAC to re-authenticate the device and provide updated network privileges is also out-of-scope.</p>
<p id="rfc.section.D.1.6.p.3">This achieves the goal of a bootstrap architecture that can integrate with NAC but does not require NAC within the network where it wasn't previously required. Future optimizations can be achieved by integrating the bootstrapping protocol directly into an initial EAP exchange.</p>
<h1 id="rfc.appendix.D.2"><a href="#rfc.appendix.D.2">D.2.</a> Domain Operator Activities</h1>
<p id="rfc.section.D.2.p.1">This section describes how an operator interacts with a domain that supports the bootstrapping as described in this document.</p>
<h1 id="rfc.appendix.D.2.1"><a href="#rfc.appendix.D.2.1">D.2.1.</a> Instantiating the Domain Certification Authority</h1>
<p id="rfc.section.D.2.1.p.1">This is a one time step by the domain administrator. This is an "off the shelf" CA with the exception that it is designed to work as an integrated part of the security solution. This precludes the use of 3rd party certification authority services that do not provide support for delegation of certificate issuance decisions to a domain managed Registration Authority.</p>
<h1 id="rfc.appendix.D.2.2"><a href="#rfc.appendix.D.2.2">D.2.2.</a> Instantiating the Registrar</h1>
<p id="rfc.section.D.2.2.p.1">This is a one time step by the domain administrator. One or more devices in the domain are configured take on a Registrar function.</p>
<p id="rfc.section.D.2.2.p.2">A device can be configured to act as a Registrar or a device can auto-select itself to take on this function, using a detection mechanism to resolve potential conflicts and setup communication with the Domain Certification Authority. Automated Registrar selection is outside scope for this document.</p>
<h1 id="rfc.appendix.D.2.3"><a href="#rfc.appendix.D.2.3">D.2.3.</a> <a href="#accepting" id="accepting">Accepting New Entities</a></h1>
<p id="rfc.section.D.2.3.p.1">For each Pledge the Registrar is informed of the unique identifier (e.g. serial number) along with the manufacturer's identifying information (e.g. manufacturer root certificate). This can happen in different ways:</p>
<p/>

<ol>
  <li>Default acceptance: In the simplest case, the new device asserts its unique identity to a Registrar. The registrar accepts all devices without authorization checks. This mode does not provide security against intruders and is not recommended.</li>
  <li>Per device acceptance: The new device asserts its unique identity to a Registrar. A non-technical human validates the identity, for example by comparing the identity displayed by the registrar (for example using a smartphone app) with the identity shown on the packaging of the device. Acceptance may be triggered by a click on a smartphone app "accept this device", or by other forms of pairing. See also <a href="#I-D.behringer-homenet-trust-bootstrap">[I-D.behringer-homenet-trust-bootstrap]</a> for how the approach could work in a homenet.</li>
  <li>Whitelist acceptance: In larger networks, neither of the previous approaches is acceptable. Default acceptance is not secure, and a manual per device methods do not scale. Here, the registrar is provided a priori with a list of identifiers of devices that belong to the network. This list can be extracted from an inventory database, or sales records. If a device is detected that is not on the list of known devices, it can still be manually accepted using the per device acceptance methods.</li>
  <li>Automated Whitelist: an automated process that builds the necessary whitelists and inserts them into the larger network domain infrastructure is plausible. Once set up, no human intervention is required in this process. Defining the exact mechanisms for this is out of scope although the registrar authorization checks is identified as the logical integration point of any future work in this area.</li>
</ol>
<p id="rfc.section.D.2.3.p.3">None of these approaches require the network to have permanent Internet connectivity. Even when the Internet based MASA service is used, it is possible to pre-fetch the required information from the MASA a priori, for example at time of purchase such that devices can enroll later. This supports use cases where the domain network may be entirely isolated during device deployment.</p>
<p id="rfc.section.D.2.3.p.4">Additional policy can be stored for future authorization decisions.  For example an expected deployment time window or that a certain Proxy must be used.</p>
<h1 id="rfc.appendix.D.2.4"><a href="#rfc.appendix.D.2.4">D.2.4.</a> Automatic Enrollment of Devices</h1>
<p id="rfc.section.D.2.4.p.1">The approach outlined in this document provides a secure zero-touch method to enroll new devices without any pre-staged configuration. New devices communicate with already enrolled devices of the domain, which proxy between the new device and a Registrar. As a result of this completely automatic operation, all devices obtain a domain based certificate.</p>
<h1 id="rfc.appendix.D.2.5"><a href="#rfc.appendix.D.2.5">D.2.5.</a> Secure Network Operations</h1>
<p id="rfc.section.D.2.5.p.1">The certificate installed in the previous step can be used for all subsequent operations. For example, to determine the boundaries of the domain: If a neighbor has a certificate from the same trust anchor it can be assumed "inside" the same organization; if not, as outside. See also <a href="#boundary">Appendix D.1.5.1</a>. The certificate can also be used to securely establish a connection between devices and central control functions. Also autonomic transactions can use the domain certificates to authenticate and/or encrypt direct interactions between devices.  The usage of the domain certificates is outside scope for this document.</p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Max Pritikin</span> 
	  <span class="n hidden">
		<span class="family-name">Pritikin</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:pritikin@cisco.com">pritikin@cisco.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Michael C. Richardson</span> 
	  <span class="n hidden">
		<span class="family-name">Richardson</span>
	  </span>
	</span>
	<span class="org vcardline">Sandelman Software Works</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mcr+ietf@sandelman.ca">mcr+ietf@sandelman.ca</a></span>

<span class="vcardline">URI: <a href="http://www.sandelman.ca/">http://www.sandelman.ca/</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Michael H. Behringer</span> 
	  <span class="n hidden">
		<span class="family-name">Behringer</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mbehring@cisco.com">mbehring@cisco.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Steinthor Bjarnason</span> 
	  <span class="n hidden">
		<span class="family-name">Bjarnason</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:sbjarnas@cisco.com">sbjarnas@cisco.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Kent Watsen</span> 
	  <span class="n hidden">
		<span class="family-name">Watsen</span>
	  </span>
	</span>
	<span class="org vcardline">Juniper Networks</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:kwatsen@juniper.net">kwatsen@juniper.net</a></span>

  </address>
</div>

</body>
</html>
